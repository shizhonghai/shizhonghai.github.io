<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript 手撕 map 方法]]></title>
      <url>%2F2020%2F10%2F16%2Fjavascript-mianshi-01%2F</url>
      <content type="text"><![CDATA[map 代码如下1234567891011121314151617181920Array.prototype.myMap = function (fn) &#123; // 判断输入的第一个参数是不是函数 if (typeof fn !== 'function') &#123; throw new TypeError(fn + 'is not a function...'); &#125; // 获取需要处理的数组内容 const arr = this, len = arr.length; // 创建一个新数组用于装载新的内容 const temp = new Array(len); // 对数组中每个值进行处理 for (let i = 0; i &lt; len; i++) &#123; // 获取第二个参数，改变 this 指向 temp[i] = fn.call(arguments[1], arr[i], i, arr); &#125; // 返回新的结果 return temp&#125;;console.log([1, 3, 4].myMap(item =&gt; item * 2)); // --&gt; [2, 6, 8]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 相关算法]]></title>
      <url>%2F2020%2F09%2F30%2Fjavascript-algorithm%2F</url>
      <content type="text"><![CDATA[冒泡排序 冒泡排序的思路：遍历数组，然后将最大数沉到最底部； 时间复杂度：O(N^2)； 空间复杂度：O(1) 作为最简单的排序算法之一，冒泡排序的思想是，从左到右依次比较两个存储数据的大小，如果第一个数大于第二个数，就交换两个数据，这样一轮比较之后，最大的数会放在后面，这样，每次循环比较，本轮中的最大值都会排到最后，直到循环结束，实现数组升序。动图演示如下： 代码如下1234567891011121314151617181920212223242526/* * 冒泡排序 * 1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。 * 2、比较完第一轮的时候，最后一个元素是最大的元素。 * 3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。 */function BubbleSort(arr) &#123; if (arr === null || arr.length === 0) &#123; return []; &#125; let len = arr.length; // 比较轮数 for (let i = 0; i &lt; len - 1; i++) &#123; // 每轮比较次数，次数=长度-1-此时的轮数 for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr;&#125;console.log('冒泡排序：', BubbleSort([10, 9, 7, 200, 100])); // [7, 9, 10, 100, 200] 选择排序 选择排序的实现思路：遍历数组，把最小数放在头部； 时间复杂度：O(N^2)； 空间复杂度：O(1) 选择排序，遍历数组，把最小数放在头部。首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，直到排序完毕。动图演示如下：代码如下 1234567891011121314151617181920212223/* * 选择排序 * 原理：遍历数组，把最小数放在头部 * 1、首先从原始数组中找到最小的元素，并把该元素放在数组的最前面 * 2、然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，直到排序完毕 */function SelectionSort(arr) &#123; if (arr === null || arr.length === 0) &#123; return []; &#125; let len = arr.length, minIndex; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; let temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125;console.log('选择排序：', SelectionSort([10, 9, 7, 200, 100])); // [7, 9, 10, 100, 200]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Webpack 相关内容]]></title>
      <url>%2F2020%2F09%2F28%2Fwebpack-related-content%2F</url>
      <content type="text"><![CDATA[问题一览 webpack与grunt、gulp的不同？ 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？ 有哪些常见的Loader？他们是解决什么问题的？ 有哪些常见的Plugin？他们是解决什么问题的？ Loader和Plugin的不同？ webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？ webpack的热更新是如何做到的？说明其原理？ 如何利用webpack来优化前端性能？（提高性能和体验） 如何提高webpack的构建速度？ 怎么配置单页应用？怎么配置多页应用？ npm打包时需要注意哪些？如何利用webpack来更好的构建？ 如何在vue项目中实现按需加载？ 问题解答1. webpack与grunt、gulp的不同？首先我们先回答这样的问题，这三者没什么可比性的。 grunt和gulp在早期比较流行，属于前端工具类，主要优化前端工作流程。比如自动刷新页面、combo、压缩css、js、css预编译等等。 现在webpack相对来说比较主流，属于预编译模块的方案，不需要在浏览器中加载解释器。另外，你在本地直接写JS，不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。 使用上的区别 grunt 和 gulp 是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 123456789gulp.task('dev',function()&#123;gulp.src('src/js/*.js').pipe(concat('all.js')) // 对其进行合并并且命名为 all.js.pipe(uglify()) // 压缩.pipe(rename('all.min.js')) // 重命名.pipe(gulp.dest('dist/js/'));// 输出压缩后的js&#125;)在目录下执行`gulp dev`即可执行上述操作// grunt这里就不在累述了，与gulp类似，只是稍微繁索一些，现在基本上用不上了 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 1234567891011module.exports = &#123; entry:'./entry.js', //入口文件 output:&#123; filename:'./bundle.js',//输出文件&#125;,module:&#123; loaders:[ ...loaders ] &#125;&#125; 总结 从构建思路来说 gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系。webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工。 对于知识背景来说 gulp更像后端开发者的思路，需要对于整个流程了如指掌。webpack更倾向于前端开发者的思路。 简单总结： gulp,grunt是web构建工具 webpack是模块化解决方案 gulp,grunt是基于任务和流 webpack基于入口文件 2. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack适用于大型复杂的前端站点构建 rollup适用于基础库的打包，如vue、react parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，因此不建议复杂的项目使用parcel 3. 有哪些常见的Loader？他们是解决什么问题的？ babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：配合css-loader使用，以 &lt;style&gt;&lt;/style&gt; 形式在html页面中插入css代码 postcss-loader：用postcss来处理CSS file-loader：将文件发送到输出的文件夹并返回URL(相对路径) url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 loader特性 loader 从右到左地取值(evaluate)/执行(execute) loader 支持链式传递,链中的每个 loader 会将转换应用在已处理过的资源上 loader 也可以内联显示指定 loader 可以是同步的，也可以是异步的 loader 运行在 Node.js 中，并且能够执行任何 Node.js 能做到的操作 loader 可以通过 options 对象配置 除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块 loader 能够产生额外的任意文件 4. 有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量(Webpack4 之后指定 mode 会自动配置) ignore-plugin：忽略部分文件 commons-chunk-plugin：提取公共代码 html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader) web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用 uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前) terser-webpack-plugin: 支持压缩 ES6 (Webpack4) mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin) webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度 serviceworker-webpack-plugin：为网页应用增加离线缓存功能 clean-webpack-plugin: 目录清理 ModuleConcatenationPlugin: 开启 Scope Hoisting speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时) webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中文首字母排序]]></title>
      <url>%2F2020%2F09%2F25%2Fjavascript-sort%2F</url>
      <content type="text"><![CDATA[StringString.prototype.localeCompare()引自MDN：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 语法12// referenceStr:引用字符串 compareString:比较字符串referenceStr.localeCompare(compareString[, locales[, options]]) 描述返回一个数字表示是否 引用字符串 在排序中位于 比较字符串 的前面，后面，或者二者相同。 当 引用字符串 在 比较字符串 前面时返回 -1 当 引用字符串 在 比较字符串 后面时返回 1 相同位置时返回 0 切勿依赖于 -1 或 1 这样特定的返回值。不同浏览器之间（以及不同浏览器版本之间） 返回的正负数的值各有不同，因为W3C规范中只要求返回值是正值和负值，而没有规定具体的值。一些浏览器可能返回-2或2或其他一些负的、正的值。 示例使用 sort()、localeCompare() 进行中文数组首字母的排序12345function compare(a, b) &#123; return a.localeCompare(b);&#125;resultArr = [ '学习' , '钢材' , '蛋汤' , '房企', '安卓','北京', '藏宝' ] ;resultArr.sort(compare); // ["安卓", "北京", "藏宝", "蛋汤", "房企", "钢材", "学习"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web Api 相关接口]]></title>
      <url>%2F2020%2F09%2F24%2Fjavascript-html-element%2F</url>
      <content type="text"><![CDATA[HTMLElementHTMLElement.offsetWidth引自MDN：是一个只读属性，返回一个元素的布局宽度。一个典型的（译者注：各浏览器的offsetWidth可能有所不同）offsetWidth是测量包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。 语法12// 返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）var offsetWidth = element.offsetWidth; 这个属性将会 round(四舍五入)为一个整数。如果你想要一个fractional(小数)值,请使用 element.getBoundingClientRect() HTMLElement.offsetHeight引自MDN：是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 语法12// 返回元素的高度（包括元素高度、内边距和边框，不包括外边距）var offsetWidth = element.offsetHeight; 这个属性值会被四舍五入为整数值，如果你需要一个浮点数值，请用 element.getBoundingClientRect() HTMLElement.clientWidth引自MDN：内联元素以及没有 CSS 样式的元素的 clientWidth 属性值为 0。Element.clientWidth 属性表示元素的内部宽度，以像素计。该属性包括内边距 padding，但不包括边框 border、外边距 margin 和垂直滚动条（如果有的话）。 语法12// 返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）和垂直滚动条（如果有的话）var intElemClientWidth = element.clientWidth; 示例 HTMLElement.clientHeight引自MDN：这个属性是只读属性，对于没有定义CSS或者内联布局盒子的元素为0，否则，它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。clientHeight 可以通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算. 语法12// 返回元素的高度（包括元素高度、内边距，不包括水平滚动条、边框和外边距）var h = element.clientHeight; 示例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中 new 一个对象的过程中发生了什么]]></title>
      <url>%2F2020%2F09%2F16%2Fjavascript-new-object-happen%2F</url>
      <content type="text"><![CDATA[我们先创建一个简单的构造函数：123456function Rocker(name)&#123; this.name = name;&#125;;Rocker.prototype.getName = function()&#123; return this.name;&#125; 这是最简单不过的构造函数了，正常情况下，我们要生成他的一个实例，只需要：1var someOne = new Rocker('Max') 这样就实例化了一个对象，但是，实例化的过程是怎样的呢？ 可能很多朋友在网上也看了很多文章，new的过程不就是三步吗？ 开辟一个块内存，创建一个空对象 执行构造函数，对这个空对象进行构造 给这个空对象添加proto属性 Or 创建一个空对象 把该对象关联到原始对象或者是构造函数 把新创建的空对象作为原始对象或者构造函数的上下文 如果原始对象或者构造函数有返回值且为对象，则返回该对象，否则返回新创建的对象 没错，是这三步，但是你真的理解了吗？至少我第一次看挺懵逼的。好吧，最直观的方法就是，把创建一个对象的过程用代码体现出来，这样才能装逼嘛…体验：让我们创建一个函数，来实现上面new操作符的功能： 1234567891011var createObject = function()&#123; var obj = new Object(), //(1) Constructor = [].shift.call(arguments); //(2) obj.__proto__ = Constructor.prototype; //(3) var ret = Constructor.apply(obj, arguments); //(4) return typeof ret === 'object' ? ret : obj; //(5)&#125;;var Freak = createObject(Rocker, 'Freak');console.log(Freak.name); //Freakconsole.log(Freak.getName()); //Freakconsole.log(Object.getPrototypeOf(Freak) === Rocker.prototype); //true 就是上面这几句代码，向你展现了一个实例被new出来的过程。 我们来简单分析一下吧，其实很清晰明了了。 在(1)处，我们创建了一个空对象（准确的说是克隆了Object.prototype对象） 接下来(2)取到构造函数，赋值给Constructor变量，也就是说Rocker构造函数变成Constructor的一个引用了 接着(3)把Constructor.prototype（也就是Rocker.prototype）赋值给(1)刚刚创建的obj的原型链，或者这么说，把obj的原型链指向Constructor的原型 (4)我们用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入（在第2步时已经用shift把第一个参数去除了），此时的ret已经是一个合格的实例了！ 保险起见，我们(5)返回时判断ret是否是对象，如果不是就返回一个空对象（因为很多人真的不会按照规矩传参！！！） 这时候我们再外部调用这个函数试试，实时证明确实能达到new的效果。 再用getPrototypeOf方法测试一下，Freak的原型链真的指向Rocker的原型！ 这就是实例被new出来的过程，你明了吗？ 转载：Rockjins Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js 算法：两数之和]]></title>
      <url>%2F2020%2F09%2F10%2Fjavascript-algorithm01%2F</url>
      <content type="text"><![CDATA[给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解一：12345678910111213141516/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; const _arr = []; for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; _arr.push(i, j); &#125; &#125; &#125; return _arr;&#125;; 解二：12345678910111213/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123; for (let i = 0; i &lt; nums.length; i++) &#123; let arrIndex = nums.findIndex(v =&gt; v === target - nums[i]) if (arrIndex !== -1 &amp;&amp; arrIndex !== i) &#123; return [i, arrIndex] &#125; &#125;&#125; 转载：https://leetcode-cn.com/problems/two-sum]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js 根据一个多维数组查询最大深度问题]]></title>
      <url>%2F2020%2F08%2F14%2Fjavascript-depth-count%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617function deep(arr, count = 0, ttt = []) &#123; for (let index in arr) &#123; if (Array.isArray(arr[index])) &#123; count++ deep(arr[index], count, ttt) &#125; else &#123; ttt.push(count) &#125; &#125; //return Math.max.apply(null, ttt) + 1 return Math.max(...ttt) + 1;&#125;let arr = [1, 2, 3, ['n', 'i', ['t', ['nihao']]], ['a', 'b']]console.log(deep(arr)) // 4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js 数组的深度递归搜索]]></title>
      <url>%2F2020%2F08%2F14%2Fjavascript-depth-recursion%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const fuck = [&#123;"label": "占用道路问题", "value": 31, "children": [&#123;"label": "经营占道", "value": 35, "children": [&#123;"label": "店外经营占道", "value": 40, "children": null &#125;, &#123;"label": "流动摊贩占道", "value": 41, "children": null &#125; ] &#125;, &#123;"label": "垃圾占道", "value": 36, "children": [&#123;"label": "生活垃圾", "value": 42, "children": null &#125;, &#123;"label": "建筑垃圾", "value": 43, "children": null &#125;, &#123;"label": "工业垃圾", "value": 44, "children": null &#125; ] &#125;, &#123;"label": "车辆占道", "value": 37, "children": [&#123;"label": "机动车占道", "value": 45, "children": null &#125;, &#123;"label": "非机动车占道", "value": 46, "children": null &#125; ] &#125;, &#123;"label": "霸占车位", "value": 38, "children": [] &#125;, &#123;"label": "其他占道", "value": 39, "children": [] &#125; ]&#125;, &#123;"label": "“两违”问题", "value": 32, "children": [&#123;"label": "违法建筑", "value": 58, "children": [&#123;"label": "房屋违建", "value": 61, "children": null &#125;, &#123;"label": "小区违建", "value": 62, "children": null &#125;, &#123;"label": "违建棚架", "value": 63, "children": null &#125; ] &#125;, &#123;"label": "违法用地", "value": 59, "children": [] &#125;, &#123;"label": "其他违建", "value": 60, "children": [] &#125; ] &#125;, &#123;"label": "市容设施管理问题", "value": 33, "children": [&#123;"label": "道路损坏", "value": 47, "children": [] &#125;, &#123;"label": "垃圾桶损坏", "value": 48, "children": [] &#125;, &#123;"label": "下水道堵塞", "value": 49, "children": [] &#125;, &#123;"label": "井盖损坏", "value": 50, "children": [] &#125;, &#123;"label": "路灯损坏", "value": 51, "children": [] &#125;, &#123;"label": "树木修剪", "value": 52, "children": [] &#125;, &#123;"label": "水电气", "value": 53, "children": [] &#125;, &#123;"label": "户外广告牌", "value": 54, "children": [] &#125;, &#123;"label": "隔音屏损坏", "value": 55, "children": [] &#125;, &#123;"label": "洒水车问题", "value": 56, "children": [] &#125;, &#123;"label": "其他", "value": 57, "children": [] &#125; ] &#125;, &#123;"label": "其他问题", "value": 34, "children": [] &#125; ]/** * 深度递归搜索 * @param &#123;Array&#125; arr 你要搜索的数组 * @param &#123;Function&#125; condition 回调函数，必须返回谓词，判断是否找到了。会传入(item, index, level)三个参数 * @param &#123;String&#125; children 子数组的key */const deepFind = (arr, condition, children) =&gt; &#123; // 即将返回的数组 let main = [] // 用try方案方便直接中止所有递归的程序 try &#123; // 开始轮询 (function poll(arr, level) &#123; // 如果传入非数组 if (!Array.isArray(arr)) return // 遍历数组 for (let i = 0; i &lt; arr.length; i++) &#123; // 获取当前项 const item = arr[i] // 先占位预设值 main[level] = item // 检验是否已经找到了 const isFind = condition &amp;&amp; condition(item, i, level) || false // 如果已经找到了 if (isFind) &#123; // 直接抛出错误中断所有轮询 throw Error // 如果存在children，那么深入递归 &#125; else if (children &amp;&amp; item[children] &amp;&amp; item[children].length) &#123; poll(item[children], level + 1) // 如果是最后一个且没有找到值，那么通过修改数组长度来删除当前项 &#125; else if (i === arr.length - 1) &#123; // 删除占位预设值 main.length = main.length - 1 &#125; &#125; &#125;)(arr, 0) // 使用try/catch是为了中止所有轮询中的任务 &#125; catch (err) &#123;&#125; // 返回最终数组 return main&#125;let resultArr = deepFind(fuck, (item, index, level) =&gt; item.value === 63, 'children');console.log(resultArr); // [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;]console.log(resultArr.map(_ =&gt; _.value)); // [32, 58, 63]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 ECharts canvas 层级太高 导致 tooltip 被遮盖]]></title>
      <url>%2F2020%2F07%2F08%2Fechart-tooltip%2F</url>
      <content type="text"><![CDATA[1234/*核心代码*/canvas &#123; z-index: -1; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sequelize 中 Model 的数据类型]]></title>
      <url>%2F2020%2F05%2F27%2Fsequelize-model-dataType%2F</url>
      <content type="text"><![CDATA[Sequelize 中 Model 的数据类型对应MySQL中的数据类型 123456789101112131415161718192021222324252627282930Sequelize.STRING // VARCHAR(255) 类型：字符串 最大值： 65535个字符Sequelize.STRING(1234) // VARCHAR(1234) 类型：变长 最大值： 65535个字符Sequelize.TEXT // TEXT 类型：字符串 最大值：65535个字符Sequelize.TEXT(&apos;tiny&apos;) // TINYTEXT 类型：字符串 最大值：255个字符Sequelize.INTEGER // INTEGER 类型：整型 最大值：范围(-2147483648~2147483647)Sequelize.BIGINT // BIGINT 类型：整型 最大值：范围(+-9.22*10的18次方)Sequelize.BIGINT(11) // BIGINT(11) 类型：整型 最大值：范围(+-9.22*10的18次方)Sequelize.FLOAT // FLOAT 类型：单精度浮点型 8位精度(4字节)Sequelize.FLOAT(11) // FLOAT(11) 类型：单精度浮点型 8位精度(4字节)Sequelize.FLOAT(11, 12) // FLOAT(11,12) 类型：精度浮点型 8位精度(4字节) m总个数，d小数位Sequelize.DOUBLE // DOUBLE 类型：双精度浮点型 16位精度(8字节) Sequelize.DOUBLE(11) // DOUBLE(11) 类型：双精度浮点型 16位精度(8字节) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) 类型：双精度浮点型 16位精度(8字节) m总个数，d小数位Sequelize.DECIMAL // DECIMAL 类型：定点数型Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) 类型：定点数型 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位Sequelize.DATE // DATETIME 类型：日期时间类型 范例：&apos;2009-05-12 02:31:44&apos;Sequelize.DATE(6) // DATETIME(6) Sequelize.DATEONLY // DATE without time.Sequelize.BOOLEAN // TINYINT(1) 类型：整型 范围(-128~127)Sequelize.ENUM(&apos;value 1&apos;, &apos;value 2&apos;) // ENUM 类型：枚举Sequelize.BLOB // BLOB 类型：二进制数据Sequelize.BLOB(&apos;tiny&apos;) // TINYBLOB 类型：二进制数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 EChart 页面多个图表，改变窗体大小图表不渲染问题]]></title>
      <url>%2F2020%2F04%2F14%2Fechart-resize%2F</url>
      <content type="text"><![CDATA[1.图表宽度需设置成 100% 2.同页面多图表请用 addEventListener 方法监听窗体大小改变 123456789// 监听窗口变化 - 只刷新最后一个图表,后定义的会覆盖前面定义的，只有1个生效window.onresize = ()=&gt; &#123; EChart.resize(); &#125;;// 监听窗口变化 - 多个图表同时刷新window.addEventListener("resize", function() &#123; EChart.resize(); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js 数组扁平化]]></title>
      <url>%2F2020%2F04%2F13%2Fjavascript-arrary%2F</url>
      <content type="text"><![CDATA[问题：[[0, 1], [2, 3], [4, 5]] -&gt; [0, 1, 2, 3, 4, 5]？ 方法一 利用 es5 的 arr.reduce(callback[, initialValue]) 实现 123let arr1 = [[0, 1], [2, 3], [4, 5]];let arr2 = arr1.reduce( (a, b) =&gt; a.concat(b) );// arr2 [0, 1, 2, 3, 4, 5] 方法二 多维数组 1234let arr = [[1,2],3,[[[4], 5]]]let flatten = (arr) =&gt; [].concat( ...arr.map(x =&gt; Array.isArray(x) ? flatten(x) : x) ) let arr2 = flatten(arr);console.log(arr2) // arr2 [1, 2, 3, 4, 5] 方法三 利用 apply 实现 123let arr1 = [[0, 1], [2, 3], [4, 5]];let arr2 = [].concat.apply([], arr1);console.log(arr2); // arr2 [0, 1, 2, 3, 4, 5] 方法四 利用 ES 的最新语法，Array.prototype.flat()。缺点是，有兼容性问题。优点是非常简单。 flat() 方法会按照一个可指定的深度递归遍历数组(默认值为1)，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 12345678910111213141516let arr1 = [1, 2, [3, 4]];let arr2 = arr1.flat(); // arr2 [1, 2, 3, 4]let arr3 = [1, 2, [3, 4, [5, 6]]];let arr4 = arr3.flat(); // arr4 [1, 2, 3, 4, [5, 6]]let arr5 = [1, 2, [3, 4, [5, 6]]];let arr6 = arr5.flat(2); // arr6 [1, 2, 3, 4, 5, 6]// 使用 Infinity，可展开任意深度的嵌套数组let arrInfinity = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];let arr7 = arrInfinity.flat(Infinity); // arr7 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// flat() 方法会移除数组中的空项，但 undefined、null 仍会保留let arr8 = [1, 2, , 4, 5];let arr9 = arr8.flat(); // arr9 [1, 2, 4, 5]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx 配置 https 并强制跳转 443 端口]]></title>
      <url>%2F2020%2F04%2F02%2Fnginx-config-https%2F</url>
      <content type="text"><![CDATA[在Nginx/Tengine服务器上安装证书 前提条件申请证书时需要选择 系统自动创建CSR。 操作指南1.登录阿里云SSL证书控制台。 2.在SSL证书页面定位到需要下载的证书(如没有证书，请先购买)，并单击下载按钮 3.在证书下载侧页面中定位到 Nginx 服务器，并单击右侧操作栏的下载，将 Nginx 服务器证书压缩包下载到本地。 4.解压已下载保存到本地的 Nginx 证书压缩包文件。解压后的文件夹中有2个文件： 证书文件：以.pem为后缀或文件类型。 密钥文件：以.key为后缀或文件类型。 5.登录您的 Nginx 服务器，在Nginx安装目录（默认Nginx安装目录为/usr/local/nginx/conf）下创建cert目录，并将下载的证书文件和密钥文件拷贝到cert目录中。 说明 如果您在申请证书时选择手动创建CSR文件，请将对应的密钥文件放到cert目录中，并命名为domain name.key。 6.修改Nginx安装目录/conf/nginx.conf文件。 按照下文中注释内容修改nginx.conf文件： 123456789101112131415161718192021222324252627282930313233# 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。server &#123; listen 443 ssl; #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。 server_name localhost; #将localhost修改为您证书绑定的域名，例如：www.example.com。 ssl_certificate ../cert/domain name.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key ../cert/domain name.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; # 以下配置主要做8086端口转发，具体配置请以实际项目为准 location / &#123; proxy_redirect off; proxy_pass_request_headers on; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://127.0.0.1:8086; &#125;&#125;# 80端口重定向到443端口server &#123; listen 80; server_name xxxx.com; # 你的域名 rewrite ^(.*)$ https://$host$1 permanent; # 把http的域名请求转成https&#125;server &#123; listen 443; server_name xxx.com; return 301 https://www.xxx.com$request_uri;&#125; 7.保存nginx.conf文件后退出。8.执行以下命令重启Nginx服务器。12nginx -s stopnginx -s start]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm 如何识别 Webpack 中的别名]]></title>
      <url>%2F2020%2F04%2F02%2Fwebstorm-webpack-config%2F</url>
      <content type="text"><![CDATA[例如：在webpack.base.config.js 文件中的别名配置1234567891011121314151617181920'use strict'const path = require('path')function resolve (dir) &#123; return path.join(__dirname, '.', dir)&#125;module.exports = &#123; context: path.resolve(__dirname, './'), resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), '@views': resolve('src/views'), '@components': resolve('src/components'), '@core': resolve('src/core'), '@utils': resolve('src/utils') &#125; &#125;,&#125; WebStorm Windows setting：File &gt; Settings &gt; Languages and Frameworks &gt;JavaScript | Webpack WebStorm MacOS setting： WebStorm | Preferences | Languages and Frameworks | JavaScript | Webpack 配置如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 下安装 pm2 后找不到 pm2 命令解决方法]]></title>
      <url>%2F2020%2F03%2F31%2Fnode-pm2%2F</url>
      <content type="text"><![CDATA[今天安装pm2碰到一个问题，使用 npm install pm2 -g 安装完成时，找不到 pm2 命令： 在安装提示中可以看到 pm2 安装位置，此时我们只要使用以下命令将 pm2 放入系统路径下就可以了： 1ln -s /usr/src/node-v12.13.0-linux-x64/bin/pm2 /usr/local/bin/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Webpack 优化总会让你不得不爱]]></title>
      <url>%2F2020%2F03%2F02%2Fwebpack-optimization%2F</url>
      <content type="text"><![CDATA[加油在家的日子不能出去玩，不能出去吃，的确是很不开心的，不过也是真的增加了好多空闲时间 与其在家呆着无聊，不如安安静静的学习一下 疫情期间，不管怎样，心态不能崩，武汉加油，中国加油 闲言少叙，现在我们就开始一起学习吧 优化是个好词优化，就是加以改变或选择使优良，在工作当中是让提升效率的好办法。当然，webpack 优化千千万，但我觉得这些就够了首当其冲的，就是工作中那些用不到的样式，可能是由于历史遗留原因已经忘记哪些是没有使用的样式了，一一排查太过耗时费力了于是，purgecss-webpack-plugin 和 glob 它俩就登场了，它的作用就是解决上面提到的问题，让我们来看看如何使用吧插件千万个，安装第一步： 1npm i purgecss-webpack-plugin glob -D 去除无用的样式工欲善其事必先利其器，装备好了，我们也来看一眼实际的情况，然后再进行有效的配置吧上图中就有一个没有被使用到的类名logo，所以如果在打包抽离出来的css文件里，肯定是不希望看到它的那么，不废话，解决它，我们开始配置吧 12345678910111213141516171819202122232425262728293031323334353637383940414243// webpack.config.js文件const path = require('path');// html模板const HtmlWebpackPlugin = require('html-webpack-plugin');// 从js中抽离出cssconst MiniCssExtractPlugin = require('mini-css-extract-plugin');// 去除无用的样式const glob = require('glob');const PurgecssWebpackPlugin = require('purgecss-webpack-plugin');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve('dist') &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125; ] &#125;, plugins: [ new HtmlWebpaclPlugin(&#123; template: './src/index.html' &#125;), new MiniCssExtractPlugin(), // 去除无用的样式 new PurgecssWebpackPlugin(&#123; paths: glob.sync('./src/**/*', &#123;nodir: true&#125;) &#125;) ]&#125;; 配置完毕了，上面包含了一些基本的配置。大家可以把重点放在注释为去除无用的样式代码部分即可了 下面我们来简单分析分析： glob是用来查找文件的 1234glob.sync('./src/**/*', &#123;nodir: true&#125;// 同步查找src目录下的任意文件夹下的任意文件// 返回一个数组，如['真实路径/src/css/style.css','真实路径/src/index.js',...]// &#123;nodir: true&#125;表示不包含文件夹，加快查找速度 purgecss-webpack-plugin是去除无用的css 12345new PurgecssWebpackPlugin(&#123; // paths表示指定要去解析的文件名数组路径 // Purgecss会去解析这些文件然后把无用的样式移除 paths: glob.sync('./src/**/*', &#123;nodir: true&#125;)&#125;) 大功告成，进入下一环节！！！ 动态添加CDN在 html 文件中引入cdn文件，在 webpack 配置 externals，这样就不会打包引入的cdn的库 123456789101112131415// index.html文件&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- 引入jquery的cdn --&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/body&gt;// webpack.config.js文件module.exports = &#123; externals: &#123; 'jquery': '$' &#125; &#125; 这样写完后，在js文件中我们就可以不用再导入jquery也能直接使用$操作符了But，这只是个过渡而已，下面有请主角登场由于每次都需要在index.html模板中手动引入需要的cdn文件，然后还要在webpack里配置，有点繁琐了So， html-webpack-externals-plugin 这样的插件就应运而生了安装步骤我就略过了，直接看代码 1234567891011121314151617181920212223242526// webpack.config.js文件// 动态添加CDNconst HtmlWebpackExternalsPlugin = require('html-webpack-externals-plugin');module.exports = &#123; plugins: [ new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; // 引入的模块 module: 'jquery', // cdn的地址 entry: 'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js', // 挂载到了window上的名称 // window.jQuery就可以全局使用 global: 'jQuery' &#125;, &#123; module: 'vue', entry: 'https://cdn.bootcss.com/vue/2.6.10/vue.min.js', global: 'Vue' &#125; ] &#125;) ]&#125;; Tree-shaking这是一个webpack内置的优化能力，webpack很好很强大，哈哈在生产环境下，Tree-shaking会进行自动删除的操作如果通过ES6的import引用的方式就会把没有用到的代码给删除掉那么在打包的时候，就不会打包那些未引用的方法了接下来，我们看个栗子：在src目录下新建一个common.js，然后在里面随便写点东东 123456789101112131415161718192021// src/common.js文件export const flatten = arr =&gt; &#123; console.log('my-flatten'); return arr.reduce((all, cur) =&gt; &#123; if (Array.isArray(cur) &#123; return [...all, ...flatten(cur)]; &#125; else &#123; return [...all, cur]; &#125; &#125;, []);&#125;;export const myBind = (fn, context) =&gt; &#123; console.log('my-bind'); let args = [].slice.call(arguments, 2); return function() &#123; let newArgs = [].slice.call(arguments); fn.apply(context, args.concat(newArgs)); &#125;&#125;; import 引用一下 123456// index.js文件import &#123; flatten &#125; from './common';let arr = [1,[3,[4, 5]], [2, [20]]];console.log(flatten(arr)); 因为只在生产环境下有效果，可以去dist文件中检查一下，是没有 console.log(&#39;my-bind&#39;) 的代码的，这就说明完美的去掉了没有引用到的代码了完美，完美，完美了 高兴的太早了，是药三分毒，有副作用的 副作用 现在我们在src目录再创建一个test.js文件，让大家再感受一下副作用 1234567// src/test.js文件export default test = () =&gt; &#123; console.log('test');&#125;test(); 此时，简单修改一下index.js 1234567// index.js文件import &#123; flatten &#125; from './common';import test from './test';let arr = [1,[3,[4, 5]], [2, [20]]];console.log(flatten(arr)); 尽管引入了test但是并没有使用，可是打包后的bundle.js文件却变化了，请看大屏幕 可想而知，副作用出现了，去dist目录下再看看bundle.js的内容，发现了打印test字段的代码。肿么办？没引用却打包进去了，表慌，让我们来将文件标记为无副作用的干掉副作用需要配合 package.json 文件，在里面添加一个 sideEffects 属性，赋值为 false 就把这些副作用给干掉了不会再打包进去了，So Easy 12345// package.json文件&#123; ...省略 "sideEffects": false&#125; 不过貌似，没有看到打包出来的css文件呢，回头看之前的截图，是打包出3个文件的，其中就包括 main.cssCSS去哪儿了？很好理解，因为我们在js中引入css文件是 import &#39;./style.css&#39; 这样，所以就出现了副作用，引用却没使用的尴尬也是因为 sideEffects: false 一股脑的全给标记过滤掉了现在修改一下 sideEffects 的值就可以，给它一个去除副作用的范围 123456// package.json文件&#123; ...省略 "sideEffects": ["./src/**/*.css"]&#125; 过滤掉引入的css文件产生的副作用，这样走丢的css文件就又找回来了至此，webpack内置的Tree-shaking就说完了，是不是很有意思，webpack大法好下面一鼓作气继续说个内置的插件，非常实用，come on baby DllPlugin动态链接库很多时候我们在开发时无论是用React还是Vue，我们都不希望这个开发的主力框架每次都被打包一遍，这样也是费时费力的事情所以，出现了DllPlugin这种插件，它纯属webpack内置的，放心大胆的用作用： 在第一次打包的时候就把打包用到的开发框架直接打包好，然后会生成一个 manifest.json 文件再打包的时候，只要有 import React from &#39;react&#39; 这样的引用，它就会先去所谓的缓存文件里找，找到了就直接用，也不用再进行对react打包了当然，如果没找到的话，再对框架打包一遍也无伤大雅 说多了，都是泪，看代码更实在，重写index.js 12345678910// index.js文件import React from 'react';import &#123; render &#125; from 'react-dom';import './style.css';render(&lt;React.Fragment&gt; &lt;h1 className="title"&gt;听妈妈的话-周杰伦&lt;/h1&gt; &lt;button className="btn"&gt;显示歌词&lt;/button&gt;&lt;/React.Fragment&gt;, window.root); 把index.js重写后我们再来npm run build打包一下看看 但是这很不科学，因为很多时候没有必要把开发框架也打包到我们写的逻辑代码中所以，接下来我们来看看DllPlugin会帮我们怎么处理吧 创建动态链接库在根目录下创建一个 webpack.dll.js 文件，用来打包出dll文件 123456789101112131415161718192021// webpack.dll.js文件const path = require('path');// 引入webpackconst webpack = require('webpack');module.exports = &#123; entry: ['react', 'react-dom'], output: &#123; filename: 'react.dll.js', path: path.resolve('dll'), library: 'react' // 打包后被引用的变量名 &#125;, plugins: [ // 动态链接库 new webpack.DllPlugin(&#123; name: 'react', path: path.resolve('dll', 'manifest.json') &#125;) ]&#125;; 代码写完了，npm run dll，之后会出现一个dll的文件夹，里面会包含你打包出来的文件，如下图打包完成后，接下来轮到我们引用的时刻到了 引用动态链接库回到我们的主战场webpack.config.js中 123456789101112131415// webpack.config.js文件const path = require('path');// 引入webpackconst webpack = require('webpack');module.exports = &#123; plugins: [ // 引用对应的动态链接库的manifest.json文件 // 这样以后再引入react的时候就会优先在json文件里去寻找 new webpack.DllReferencePlugin(&#123; manifest: path.resolve('dll', 'manifest.json') &#125;) ]&#125;; 写到这里还不算完，还需要在src目录下的index.html模板中引入一下&lt;script src=&quot;../dll/react.dll.js&quot;&gt;&lt;/script&gt;插一句：之所以，会新建一个dll目录，因为在 npm run dev 开发环境编译的时候，dist目录的内容都在内存中了，是找不到react.dll.js文件的好了，现在让我们看看效果吧，npm run dev 启动一下 当然，也许有人会问，如果需要引入的文件比较多怎么办？每次在index.html中手动引入毕竟不是长久之计，那么接下来就再看一个好东东 动态引入js通过 add-asset-html-webpack-plugin 插件就可以完成这样的需求，来看代码 123456789101112131415161718// webpack.config.js文件const webpack = require('webpack');// 添加资源到html文件const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');module.exports = &#123; plugins: [ // 引用打包好的react，不会打包到bundle里 new webpack.DllReferencePlugin(&#123; manifest: path.resolve('dll', 'manifest.json') &#125;), // 直接将打包好的react.dll.js添加到html模板 new AddAssetHtmlWebpackPlugin(&#123; filepath: path.resolve('dll', 'react.dll.js') &#125;) ]&#125;; 通过上面的改造后，就动态的把react.dll.js文件添加到html文件中了。 我们之前在index.html模板里手动引入js的那一行就可以删除掉了 懒加载说到懒加载必然是一种很好的优化网页或应用的方式，那么在webpack中也是通过ES6的 import() 语法来引入的。虽然这个 import() 语法目前还处在草案的第三阶段，不过并不影响大家对它的一致好评用过Vue-Router的同学都知道，大家写的路由通过 component: () =&gt; import() 的方式，也是可以进行懒加载的So，好饭不怕晚，早晚会成为正式一员的。下面还是用实际栗子演示一下吧 12345678910111213141516171819202122232425262728293031323334353637// index.js文件import './style.css';import React from 'react';import &#123; render &#125; from 'react-dom';// 写个辅助的类class Music extends React.Component &#123; constructor() &#123; super(); this.state = &#123; lrc: [] &#125;; &#125; showLrc() &#123; // 通过ES6的import()方法实现了懒加载功能，实际上是利用了jsonp去动态导入了 import('./lrc').then(data =&gt; &#123; let lrc = data.default.split('\n').filter(item =&gt; item !== ''); this.setState(&#123; lrc &#125;); &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button className="btn" onClick=&#123;() =&gt; this.showLrc()&#125;&gt;显示歌词&lt;/button&gt; &lt;div className="lrc-box"&gt; &#123;this.state.lrc &amp;&amp; this.state.lrc.map((item, index) =&gt; ( &lt;p className="lrc" key=&#123;index&#125;&gt;&#123;item&#125;&lt;/p&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;render(&lt;React.Fragment&gt; &lt;h1 className="title"&gt;听妈妈的话-周杰伦&lt;/h1&gt; &lt;Music&gt;&lt;/Music&gt;&lt;/React.Fragment&gt;, window.root); npm run dev 让我们看看是不是有了懒加载的效果通过上面的gif图可以看到，当点击显示歌词的时候，加载了一个0.bundle.js文件这个文件就是我们通过懒加载导入的lrc.js文件，由此可见，懒加载功能验证成功，撒花 接下来再来个老生常谈的优化，请继续往下看，不要停 抽取公共代码开发的时候，经常会有不同的模块引用了同一个第三方包。这里举个栗子，比如有两个js文件，一个是index.js另一个是lrc.js，它们都引用了著名的实用工具库lodash，代码如下下下 123456789// index.js文件import _ from 'lodash';console.log(_.xor([2, 1], [2, 3]));// lrc.js文件import _ from 'lodash';console.log(_.flatten([1,[3, 4, 5, [2]]])); 看完以上代码就明白了，他们的公共部分就是都引了lodash，这样会分别打包到他们所在的文件中去，这样打包的js文件就会很大了 所以，必须得把lodash提取出来，废话不多说，看招 抽取第三方模块1234567891011121314151617// webpack.config.js文件module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; chunks: 'initial', minSize: 0, minChunks: 2, test: /node_modules/, priority: 1 &#125; &#125; &#125; &#125;&#125;; webpack4中自带了抽取公共代码的方法，通过optimization里的splitChunks来做到抽离第三方模块有两点好处 不会和业务逻辑打包在一起 增加缓存 304 抽取公共模块当然了，项目中很多js文件不仅仅会引用第三方模块来开发，我们也会使用写好的公共模块，那么是不是也可以提取出来呢？ 1234567// index.js文件import &#123; flatten &#125; from './common';console.log('index',flatten([1,[33, 4, 5, [34]]]));// lrc.js文件import &#123;flatten&#125; from './common';console.log(flatten([1,[33, 4, 5, [34]]])); 上面在两个js文件中都引入了common.js中写好的flatten方法，既然它们都引用到了common.js，所以想当然的也可以把它抽取出来的 那么参照提取第三方代码的实现来写一下吧 123456789101112131415// webpack.config.js文件module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; utils: &#123; chunks: 'initial', minSize: 0, minChunks: 2 &#125; &#125; &#125; &#125;&#125;; 以上就是抽取公共代码部分了，到此为止了 热更新热更新对于开发来说可以说是非常高效的，而且webpack现在也自带插件支持热更新了 通过 devServer 来启动热更新 ☆：devServer的使用需要在项目中提前安好 webpack-dev-server 那么我们先来看看配置部分： 123456789101112131415161718// webpack.config.js文件// 引入webpackconst webpack = require('webpack');module.exports = &#123; devServer: &#123; hot: true, // 启动热更新 port: 8080, contentBase: './dist' &#125;, plugins: [ // webpack支持热更新插件 new webpack.HotModuleReplacementPlugin(), // 打印更新了的文件路径 new webpack.NamedModulesPlugin() ]&#125;; 热更新只适合在开发环境下来搞，所以配置好后，再执行 npm run dev 现在让我们回到index.js文件里去，让我们感受一下 // index.js文件 12345678910111213// 热更新// 在src目录下新创建了audio.js文件// 需要导入这个文件，不然热更新失效import audio from './audio';// 检查是否支持热更新if (module.hot) &#123; // 接收热更新的模块 module.hot.accept('./audio.js', (path) =&gt; &#123; console.log(path); console.log('audio文件更新了'); &#125;);&#125; 这样就完成了热更新操作，接收了audio.js文件，所以在audio.js文件内部如果进行修改保存后，会在控制台里展示对应的更新信息，如下图 热更新现在可是开发中的老朋友，很多IDE都配置了热更新操作，比如像Android Studio这样的编译器，通过热更新来加快编译速度好了，不啰嗦了，下面还是干货满满的，Enjoy it 跨域请求严格意义上来讲，通过webpack来做跨域请求实际上也不能算在优化里。不过在开发中，这种跨域的情况还是很多的，了解了也不吃亏，一起看看吧 还是通过老朋友devServer来实现的，上代码 第一种跨域方式1234567891011121314151617// webpack.config.js文件module.exports = &#123; devServer: &#123; proxy: &#123; // 可以这样写 // '/api': 'http://localhost:3000', // 也可以这样写，多配置 '/api': &#123; target: 'http://localhost:3000', pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125;; 通过devServer提供的proxy属性，可以完成我们想要的跨域请求，下面看看参数都是干什么的 target指定要跨域请求的url比如你请求/api/userInfo就会代理到http://localhost:3000/api/userInfo pathRewrite顾名思义，重写路径接口不可能都是/api开头的，所以如果遇到个接口是/getSongs而不是/api/getSongs的接口地址，会把以/api重写改为空字符最后就可以访问http://localhost:3000/getSongs 第二种跨域方式1234567891011121314151617// webpack.config.js文件module.exports = &#123; devServer: &#123; // 利用node来写 before(app) &#123; // 相当于直接写了后端的接口，哈哈 app.get('/api/info', (req, res) =&gt; &#123; res.json(&#123; nickname: '我滴个大榴莲啊', level: 8, src: 'https://music.163.com/song/media/outer/url?id=1382794914.mp3' &#125;); &#125;); &#125; &#125;&#125;; 当然，以上两种方式大家知道即可了，第一种也是最普遍的实现方式，妈妈再也不用担心我的跨域问题了 IgnorePlugin作用： 忽略打包第三方模块指定的目录 为什么要忽略呢？ 通过下面的栗子来看一下 相信很多人应该或多或少的都听过moment这个时间库，不知道也没关系，我来演示一波 先安装moment： npm i moment -S 12345678910// index.js文件// 导入momentimport moment from 'moment';// 设置中文moment.locale('zh-cn');let time = moment().endOf('day').fromNow();window.root.innerHTML += time; 页面上展示的一点毛病都没有，不过如果看一下打包的情况就会发现有瑕疵了，你看 设置了中文，却把整个语言包都打包进去了，这样很不好这是神马原因呢，其实是因为moment被导入的时候，附赠了整个locale语言包，这种买一赠一的行为就不用提现在代码世界了，吃不消了 我们需要用中文包，但是不想打包全部语言包，就让IgnorePlugin出马了 12345678910// webpack.config.js文件const webpack = require('webpack');module.exports = &#123; plugins: [ // 忽略moment目录下的locale文件夹 new webpack.IgnorePlugin(/\.\/locale/, /moment/) ]&#125;; 配置改写后，再回到index.js中单独导入中文语言包就好了 12345678910// index.js文件// 利用IgnorePlugin把只需要的语言包导入使用就可以了，省去了一下子打包整个语言包import moment from 'moment';// 单独导入中文语言包import 'moment/locale/zh-cn';let time = moment().endOf('day').fromNow();window.root.innerHTML += time; 再重新 npm run build 打包后，体积瞬间减少了278k啊啊啊啊，下图显示 noParsenoParse的作用是不去解析你所使用的第三方库中的依赖库 废话不多说，直接上代码 12345678910111213141516// webpack.config.js文件module.exports = &#123; module: &#123; // 不去解析jquery或lodash中的依赖库 noParse: /jquery|lodash/, rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;&#125; 在工作中，忽略大型的库可以提高构建性能，可以从构建时间上看出来速度的提升，如上面代码中提到的jquery和lodash resolve从这个英文就能看出来，它就是配置模块如何解析用的，配置太多也没必要一一介绍了，还是直接说重点写出常用的配置吧 resolve常用配置 modules指定解析第三方包的目录位置 alias指定import导入时的别名，简化引入 extensions自动解析确定好的扩展名默认会把js和json当做扩展名 1234567891011121314// webpack.config.js文件const &#123; resolve &#125; = require('path');module.exports = &#123; resolve: &#123; modules: [resolve('node_modules')], alias: &#123; Utils: resolve(__dirname, 'src/utils/'), '@': resolve(__dirname, 'src') &#125;, extensions: ['.js', '.css', '.json'] &#125;&#125; 此刻，我们往src目录下创建一个utils文件夹，然后新建一个parse-url.js文件 123456789101112// src/utils/parse-url.js文件// 就简单导出一下export default '我是解析url的方法';// src/index.js文件import parseUrl from 'Utils/parse-url';console.log(parseUrl); // 打印：我是解析url的方法 上面代码为我们展示了alias别名的效果，真的是很有用很方便的，哈哈 include和exclude include: 包含指定目录下的文件解析 exclude: 排除指定目录不进行解析二者使用一个即可了，想必这个优化的点大家并不陌生的，看眼代码吧 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader' &#125;, exculde: /node_modules/, // 二选一 include: path.resolve('src') // 二选一 &#125; ] &#125;&#125; happypackwebpack在Node环境下运行所以也是单线程操作，一件一件的去处理事情。这样很不nice，本着现在cpu都那么威猛的情况下，运用多核运算完全是小儿科的于是乎，就有了happypack的用武之地了，它的作用就是可以实现多进程打包操作下面我们再来看下是如何配置的配置前先来安装一下 npm i happypack -D 1234567891011121314151617181920212223242526272829303132333435363738// webpack.config.js文件const Happypack = require('happypack');module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, use: 'Happypack/loader?id=js' &#125;, &#123; test: /\.css$/, use: 'Happypack/loader?id=css' &#125; ] &#125;, plugins: [ new Happypack(&#123; id: 'js', use: [ &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env', '@babel/preset-react' ] &#125; &#125; ] &#125;), new Happypack(&#123; id: 'css', use: ['style-loader', 'css-loader'] &#125;) ]&#125; 差不多了，大家真的辛苦了，哈哈，坚持看下来的小伙伴，真是太给力了 简单几句优化的内容有多种多样，也不会全部都包含，上面提到的也都是比较常见的一些优化方式，各取所需、各取所用就好了 还是那句话，疫情总会过去的，没什么好怕的，一起努力吧！！！ 感谢大家，886 文章来源：Webpack 优化总会让你不得不爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[lowdb]]></title>
      <url>%2F2020%2F02%2F21%2Flowdb%2F</url>
      <content type="text"><![CDATA[NPM 源地址 ： https://www.npmjs.com/package/lowdb 用于Node，Electron和浏览器的小型JSON数据库。由Lodash提供技术支持 123db.get('posts') .push(&#123; id: 1, title: 'lowdb is awesome'&#125;) .write() 用法1npm install lowdb 1234567891011121314const low = require('lowdb');const FileSync = require('lowdb/adapters/FileSync');const adapter = new FileSync('db.json'); // 存储到db.json文件中const db = low(adapter); // 设置一些默认值db.defaults(&#123;posts: [], user: &#123;&#125;&#125;).write();// 添加一个postdb.get('posts').push(&#123;id: 1, title: 'lowdb is awesome'&#125;).write();// 使用Lodash简写语法设置用户db.set('user.name', 'typicode').write(); 数据保存到db.json12345678&#123; "posts": [ &#123; "id": 1, "title": "lowdb is awesome"&#125; ], "user": &#123; "name": "typicode" &#125;&#125; 你可以使用任何 lodash 函数 _.get 和 _.find 简写语法 12// 如果您只是从db读取，请使用.value（）而不是.write（）db.get('posts').find(&#123;id: 1&#125;).value(); Lowdb 非常适合 CLI，小型服务器，Electron 应用程序和 npm 软件包。 它支持Node，浏览器并使用lodash API，因此学习起来非常简单。实际上，如果你知道Lodash，你已经知道如何使用lowdb 用法示例 CLI 浏览器 服务器 In-memory JSFiddle实例 重要的 lowdb 不支持群集，并且可能存在非常大的JSON文件（~200MB）的问题。 在 unpkg 上也可以使用UMD构建进行测试和快速原型设计：1234567&lt;script src="https://unpkg.com/lodash@4/lodash.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/lowdb@0.17/dist/low.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/lowdb@0.17/dist/LocalStorage.min.js"&gt;&lt;/script&gt;&lt;script&gt; var adapter = new LocalStorage('db') var db = low(adapter)&lt;/script&gt; API1.low(adapter)返回具有下面描述的其他属性和函数的lodash 链 2.db.[…].write() db.[…].value()write() 是一个语法糖，用于调用 value() 和 db.write() 一行。另一方面，value() 只是 _.protoype.value() 并且应该用于执行不更改数据库状态的链。1234db.set('user.name', 'typicode').write()// 相当于db.set('user.name', 'typicode').value()db.write() 3.db._数据库lodash实例。使用它来添加自己的实用程序函数或第三方mixins，如 underscore-contrib 或 lodash-id。123456db._.mixin(&#123; second: function(array)&#123; return array[1] &#125;&#125;)db.get('posts').second().value() 4.db.getState()返回数据库状态1db.getState() // &#123;posts:[...]&#125; 5.db.setState(nweState)替换数据库状态 db.json 内容没变12const newState = &#123;&#125;db.setState(newState) 6.db.write()使用持久化数据库adapter.write（取决于adapter，可能会返回一个promise）。123456// 使用 lowdb/adapter/FileSync 同步db.write()console.log('state has been saved'); // 状态已保存// 使用lowdb/adapter/FileAsyncdb.write().then(()=&gt;console.log('state has been saved')) 7.db.read()使用storage.read选项读取源代码（取决于adapter，可能会返回一个promise）123456// 使用 lowdb/FileSyncdb.read()console.log('State has been updated') // 状态已更新// 使用 lowdb/FileAsyncdb.read().then(()=&gt;console.log('State has been updated')) apapter API请注意，这仅适用于与Lowdb捆绑在一起的适配器。第三方适配器可能有不同的选项。 为了方便，FileSync，FileAsync 和 LocalBrowser 接受以下选项： defaultValue 如果文件不存在，则该值将被用于设定初始状态（default：{}） serialize/deserialize 在写入之前和读取之后使用的函数（default：JSON.stringify 和 JSON.parse ） 序列化/反序列化12345const adapter = new FileSync('array.yaml', &#123; defaultValue: [], serialize: (array) =&gt; toYamlString(array), deserialize: (string) =&gt; fromYamlString(string)&#125;) 指南使用Lowdb，您可以访问整个lodash API，因此有很多方法来查询和操作数据 请注意，数据是通过引用返回的，这意味着对返回对象的修改可能会更改数据库。为了避免这种行为，您需要使用.cloneDeep(). 此外，方法的执行是懒惰的，也就是说，延迟执行直到调用value()或.write() 检查posts是否存在1db.has('posts').value() 设置posts1db.set('posts', []).write() 排序前五个 posts (文章)12345db.get('posts') .filter(&#123;published: true&#125;) .sortBy('views') .task(5) .value() 获取文章标题123db.get('posts) .map('title') .value() 获取文章数量123db.get('posts') .size() .value() 使用路径获取第一篇文章的标题。12db.get('posts[0].title') .value() 更新一个post1234db.get('posts') .find(&#123;title: 'low!'&#125;) .assign(&#123;title: 'hi!'&#125;) .write() 删除 posts123db.get('posts') .remove(&#123;title: 'low!'&#125;) .write() 移除属性12db.unset('user.name') .write() 深克隆 posts123db.get('posts') .cloneDeep() .value() 如何使用基于id的资源能够使用id获取数据非常有用，尤其是在服务器中。要向lowdb添加基于id的资源支持，您有2个选项 shortid 更简约，并返回一个可在创建资源时使用的唯一ID。123456789101112const shortid = require('shortid')const postId = db .get('posts') .push(&#123; id: shortid.generate(), title: 'low!' &#125;) .write() .idconst post = db .get('posts') .find(&#123; id: postId &#125;) .value() lodash-id 提供了一组帮助程序，用于创建和操作基于id的资源。1234567891011121314const lodashId = require('lodash-id')const db = low('db.json')db._.mixin(lodashId)const post = db .get('posts') .insert(&#123; title: 'low!' &#125;) .write()const post = db .get('posts') .getById(post.id) .value( 如何创建自定义的适配器low() 接受自定义适配器，因此您可以使用任何格式将数据虚拟地保存到任何存储。12345678910111213141516class &#123; constructor （） &#123; // ... &#125; read （） &#123; // 应返回数据（对象或数组）或Promise &#125; write(data)&#123; // 不应该返回任何内容或Promise &#125;&#125; const adapter = new MyStorage（ args ） const db = low （） See src/adapters for examples. 查看例子 如何加密数据FileSync，FileAsync 和 LocalStorage 接受自定义 serialize 和 deserialize 功能。您可以使用它们来添加加密逻辑。 1234const adapter = new FileSync('db.json', &#123; serialize: (data) =&gt; encrypt(JSON.stringify(data)) // 加密 deserialize: (data) =&gt; JSON.parse(decrypt(data)) // 解密&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 GitHub 相关技巧]]></title>
      <url>%2F2020%2F01%2F15%2Fgithub%2F</url>
      <content type="text"><![CDATA[显示 GitHub Stars 数量 (官方文档地址：https://shields.io/)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 忽略规则以及 .gitignore 文件不生效解决办法]]></title>
      <url>%2F2020%2F01%2F07%2Fgitignore%2F</url>
      <content type="text"><![CDATA[Git 忽略规则#此为注释 – 内容被 Git 忽略 .sample # 忽略所有 .sample 结尾的文件 !lib.sample # 但 lib.sample 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore 规则不生效的解决办法把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交 123git rm -rf --cached .git add .git commit -m &apos;update .gitignore&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日一题（2019-10-29）]]></title>
      <url>%2F2019%2F12%2F12%2FDaily-Interview-Question-2%2F</url>
      <content type="text"><![CDATA[第 0002 题：Vue 中的 computed 和 watch 的区别在哪里computed：计算属性 计算属性是由 data 中的已知值，得到的一个新值。 这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。 计算属性不在 data 中，计算属性新值的相关已知值在 data 中。 具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数。 别人变化影响我自己。 watch：监听数据的变化 监听data中数据的变化。 监听的数据就是data中的已知值。 无缓存性，页面重新渲染时值不变化也会执行。 我的变化影响别人。 公司：虾皮 watch 擅长处理的场景：一个数据影响多个数据 computed 擅长处理的场景：一个数据受多个数据影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日一题（2019-11-01）]]></title>
      <url>%2F2019%2F12%2F12%2FDaily-Interview-Question-3%2F</url>
      <content type="text"><![CDATA[第 0003 题：webpack 中 loader 和 plugin 的区别是什么loader 它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务 公司：平安]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 Hexo Cannot find module './build/Release/DTraceProviderBindings' 错误]]></title>
      <url>%2F2019%2F12%2F12%2Fhexo-error-DTraceProviderBindings%2F</url>
      <content type="text"><![CDATA[hexo 报错1Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos; 解决办法 on googlegoogle之后发现被这个问题困扰的小伙伴还真不少，网上最靠谱的解决办法是： 1$ npm install hexo --no-optional 的确很多小伙伴执行上面的命令之后都解决了报错的问题，但也有很多小伙伴跟我一样执行后没有任何效果，我甚至尝试了卸载后重装的方式： 12$ npm uninstall hexo$ npm install hexo --no-optional 可是依旧没有效果。其实 hexo 暂时并没有用到 dtrace-prodider ，仅仅是报错而已，hexo 的命令还是能执行，但对于强迫症来说，简直无法忍受。 我的解决办法一番折腾之后，我找到了适合我的解决办法，重装 hexo-cli，如果命令行报没权限错误，请记得前面加 sudo : 12$ npm uninstall hexo-cli -g$ npm install hexo-cli -g 再来执行 hexo 命令果然没有报错信息了:D]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义 Echarts 图表悬浮框的位置]]></title>
      <url>%2F2019%2F08%2F12%2Fecharts-tooltip%2F</url>
      <content type="text"><![CDATA[由于项目需求，悬浮框内容较多，会出现悬浮框(tooltip)很长或者很宽的现象，而太长了，就会被 Echarts 溢出隐藏了，所以需要自定义定位需求 需求描述：鼠标悬浮在左侧某一个点时，悬浮框悬停在点的右侧；鼠标悬停在右侧某一个点时，悬浮框悬停在点的左侧。 首先明确一点，我们需要借助 tooltip.position 属性。理想的思路是我们在回调函数中获取鼠标每次悬停的坐标，然后再判断这个坐标是否处于此容器(也就是这个Echarts图表)的左侧或者右侧；判断命中后我们再改变 tooltip 的位置，并返回给函数。 效果图：【左侧悬浮】 效果图：【右侧悬浮】 效果图：【溢出显示】 1234567891011121314151617// 关健代码tooltip: &#123; position: function (position) &#123; let dom = document.getElementById('chartDom'); if (dom) &#123; // 获取容器的宽度 let chartsWidth = dom.offsetWidth; // 判断悬停点落在容器的哪测 if (position[0] &lt; (chartsWidth / 2)) &#123; position[0] = position[0]; &#125; else &#123; position[0] = position[0] - 130; &#125; &#125; return [position[0], position[1]]; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React 生命周期]]></title>
      <url>%2F2019%2F08%2F02%2Freact-component%2F</url>
      <content type="text"><![CDATA[防止自己忘掉 React 的一些生命周期方法，方便自己回忆和查阅。 componentDidUpdate() componentDidUpdate(prevProps, prevState, snapshot) componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。 当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。 123456componentDidUpdate(prevProps) &#123; // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125;&#125; 你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 技巧]]></title>
      <url>%2F2019%2F07%2F26%2FCSS-skill%2F</url>
      <content type="text"><![CDATA[padding 配合 background-clip 属性，可以制作一些特殊形状：123456789101112131415161718192021222324/*三道杠*/.icon1 &#123; box-sizing: border-box; display: inline-block; width: 12px; height: 10px; padding: 2px 0; border-top: 2px solid currentColor; border-bottom: 2px solid currentColor; background: currentColor; /*注意如果此处背景颜色属性用缩写的话，需要放到其他背景属性的前面，否则会覆盖前面的属性值（此处为background-clip）为默认值*/ background-clip: content-box;&#125;/*双层圆点*/.icon2 &#123; display: inline-block; width: 12px; height: 12px; padding: 2px; border: 2px solid currentColor; border-radius: 50%; background-color: currentColor; background-clip: content-box;&#125; .icon1 { box-sizing: border-box; display: inline-block; width: 12px; height: 10px; padding: 2px 0; margin-right: 20px; border-top: 2px solid currentColor; border-bottom: 2px solid currentColor; background: currentColor; background-clip: content-box; } /*双层圆点*/ .icon2 { display: inline-block; width: 12px; height: 12px; padding: 2px; border: 2px solid currentColor; border-radius: 50%; background-color: currentColor; background-clip: content-box; } 实时预览如下：（currentColor 是 css 中为数不多的变量，指当前文字的颜色值，非常好用）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日一题（2019-07-18）]]></title>
      <url>%2F2019%2F07%2F18%2FDaily-Interview-Question-1%2F</url>
      <content type="text"><![CDATA[第 0001 题：请写出如下代码的打印结果123456789var name = 'Tom';(function() &#123; if (typeof name == 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 公司：京东 【答案】：Goodbye Jack 【解析】：var 关键字有变量提升，它定义的变量会提升到函数的顶部。题目中立即执行函数的中的变量 name 的定义被提升到了顶部，并在初始化赋值之前是 undefined，所以 typeof name == &#39;undefined。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 名词解释]]></title>
      <url>%2F2019%2F07%2F18%2Fjavascript-glossary%2F</url>
      <content type="text"><![CDATA[变量提升（hoisting）var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可能是你需要的 react + typescript 50条规范和经验]]></title>
      <url>%2F2019%2F07%2F11%2Freact-typescript%2F</url>
      <content type="text"><![CDATA[注释文件顶部的注释，包括描述、作者、日期12345/** * @description xxxxxx * @author chengfeng * @since 19/05/21 */ 模块的注释123456/** * 拷贝数据 * @param &#123;*&#125; data 要拷贝的源数据 * @param &#123;boolean&#125; [isDeep=false] 是否深拷贝，默认浅拷贝 * @return &#123;*&#125; 返回拷贝后的数据 */ 业务代码注释1/*业务代码注释*/ 变量注释12345678interface IState &#123; // 名字 name: string; // 电话 phone: number; // 地址 address: string;&#125; 引用组件顺序 先引用外部组件库,,再引用当前组件块级组件, 然后是 common 里的公共函数库最后是 css 样式 12345import * as React from 'react';import &#123; Dropdown, Menu, Icon &#125; from 'antd';import Header from './Header';import toast from 'common/toast';import './index.less'; 引号 使用单引号,或者 es6 的反引号 缩进 使用两个空格 1234const handleCheck = () =&gt; &#123; onCancel &amp;&amp; onCancel(); onClose &amp;&amp; onClose();&#125;; 分号 每行末尾都要加分号。 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。1234567// not goodif (condition) doSomething();// goodif (condition) &#123; doSomething();&#125; 空格 二元和三元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 123456789// bad++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2; 用作代码块起始的左花括号 { 前必须有一个空格。 12345678910111213141516171819// badif (condition)&#123;&#125;while (condition)&#123;&#125;function funcName()&#123;&#125;// goodif (condition) &#123;&#125;while (condition) &#123;&#125;function funcName() &#123;&#125; if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 12345678910111213141516171819// badif(condition) &#123;&#125;while(condition) &#123;&#125;(function() &#123;&#125;)();// goodif (condition) &#123;&#125;while (condition) &#123;&#125;(function () &#123;&#125;)(); 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 12345678910111213// badvar obj = &#123; a : 1, b:2, c :3&#125;;// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;; 换行 每个独立语句结束后必须换行。 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行 1234567891011121314151617181920212223242526272829303132333435// badvar obj = &#123; a: 1 , b: 2 , c: 3,&#125;;function test()&#123; ...&#125;for (const key in object) &#123; if (object.hasOwnProperty(key)) &#123; const element = object[key]; &#125;&#125;// goodvar obj = &#123; a: 1, b: 2, c: 3,&#125;;function test() &#123; ...&#125;for (const key in object) &#123; if (object.hasOwnProperty(key)) &#123; const element = object[key]; &#125;&#125; 下列关键字后：else, catch, finally 不需要换行 123456789101112131415161718192021222324252627282930313233// badif (condition) &#123; ...&#125;else &#123; ...&#125;try &#123; ...&#125;catch (e) &#123; ...&#125;finally &#123; ...&#125;// goodif (condition) &#123; ...&#125; else &#123; ...&#125;try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 数组、对象 对象属性名不需要加引号； 对象以缩进的形式书写，不要写在一行； 数组最后不要有逗号。 对象最后要有逗号。 1234567891011121314151617181920// badconst a = &#123; 'b': 1&#125;;const a = &#123;b: 1&#125;;const a = &#123; b: 1, c: 2&#125;;const arr = [1, 2, 3, 4,];// goodconst a = &#123; b: 1, c: 2,&#125;;const arr = [1, 2, 3, 4]; 命名 类名: 大驼峰式风格，字母和数字，例如：AbcTest。禁止汉字、特殊符号，禁止非大驼峰式风格。 函数名: 小驼峰式风格，字母和数字，例如：abcTest。禁止汉字、特殊符号，禁止非小驼峰式风格，例如snake_case等。 变量名: 同函数名。 常量: 全大写风格，大写字母、数字和下划线，单词之间以下划线分隔，例如：ABC_TEST。禁止汉字、特殊符号、小写字母。 使用 onXxx 形式作为 props 中用于回调的属性名称。 1234interface IProps &#123; onClose?: () =&gt; void; onOk?: (item: Record&lt;string, any&gt;) =&gt; void;&#125; 组件内的事件函数使用 handle 开头尾,handleCheckBtn。 使用 withXxx 形式的词作为高阶组件的名称。 接口命名前面带上 I 表示 interface 12interface IProps &#123;&#125;interface IState &#123;&#125; 类型断言12345678910111213141516171819202122232425// badfunction getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'.// bad function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125;// goodfunction getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125; interface声明顺序日常用到比较多的是四种，只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后12345678interface iProps &#123; readonly x: number; readonly y: number; name: string; age: number; height?: number; [propName: string]: any;&#125; ts好用的相关工具泛型 Record&lt;string,any&gt; 用这个来声明对象结构的类型 12345// 用于定义一个javascript的对象，key是字符串，value是任意类型const people:Record&lt;string,any&gt; = &#123; name: 'chengfeng', age: 10&#125; Partial 作用是将传入的属性变为可选项. 123456789interface iPeople &#123; title: string; name: string;&#125;const people: Partial&lt;Todo&gt; = &#123; title: 'Delete inactive users',&#125;;定义的结构可以是接口iPeople的任意key Readonly 作用是将传入的属性变为变成只读 12345678910interface iPeople &#123; title: string; name: string;&#125;const people: Readonly&lt;Todo&gt; = &#123; title: 'todo list', name: 'chenfeng';&#125;;title name属性就是只读的了 Required 的作用是将传入的属性变为必选项 123456interface iPeople &#123; title?: string; name?: string;&#125;const people1: Props = &#123; title: 'ts' &#125;; // OKconst people22: Required&lt;iPeople&gt; = &#123; title: 'ts' &#125;; // Error: property 'name' missing ts一些好用的小tips keyof 123456interface iPeople &#123; name: string; age: number&#125;type T = keyof iPeople // -&gt; "name" | "age" in 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; 规范其他 不要使用 var 声明变量 不会被修改的变量使用 const 声明 去除声明但未被引用的代码 禁止在代码里使用 debug 不允许有空的代码块 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state，123456789// badconstructor ()&#123; this.setState(&#123; people: this.props.people &#125;)&#125;// goodstate: IState = &#123; people: &#123;&#125;,&#125;; 渲染默认值 添加非空判断可以提高代码的稳健性,例如后端返回的一些值,可能会出现不存在的情况，应该要给默认值. 123456789// badrender()&#123; &#123;name&#125;&#125;// goodrender()&#123; &#123;name || ''&#125;&#125; 还有一种情况，就是本来后端应该返回一个数组给你，但是数据库取不到数据，可能后端给你返回了null,然后前端null.length。这样就gg了 123456789101112131415161718192021// badconst &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);list 可能是null或者undefinedlist.length将直接导致前端报错this.setState(&#123; status: STATUS.READY, apps: list, total: totalCount, page: page,&#125;);// good const &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);this.setState(&#123; status: STATUS.READY, apps: list || [], total: totalCount || 0, page: page,&#125;); 不确定的属性，最后却疯狂的用…访问不存在的属性例如一些地方，不确定这个变量里面到底有什么，但自己觉得有，就疯狂的…,最明显的就是后端返回了一个对象给你，前端拿到之后判断都不判断直接 data.dataList.forEach()123456789// badconst data = await getPeopleList(keyword, page, pageSize);data.dataList.forEach() // 直接挂了// goodconst data = await getPeopleList(keyword, page, pageSize);if (data &amp;&amp; data.dataList &amp;&amp; Array.isArray(data.dataList) &#123; data.dataList.forEach() &#125; 数据格式转换把字符串转整型可以使用 + 号12let maxPrice = +form.maxPrice.value;let maxPrice = Number(form.maxPrice.value); 转成 boolean 值用 !!1let mobile = !!ua.match(/iPhone|iPad|Android|iPod|Windows Phone/); 判断条件真假js 中以下为假,其他情况为真 false null undefined 0 ‘’ (空字符串) NaN 简单组件可以使用函数代替1234567891011// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; 对于常用的属性进行缓存12345678// badthis.props.app.openid;this.state.time// goodconst &#123; app &#125; = this.props;const &#123; time &#125; = this.state;console.log(app.openid) input 输入框使用 trim()12345678// badthis.props.app.openid;this.state.time// goodconst &#123; app &#125; = this.props;const &#123; time &#125; = this.state;console.log(app.openid) 使用 location 跳转前需要先转义12345// badwindow.location.href = redirectUrl + '?a=10&amp;b=20';// goodwindow.location.href = redirectUrl + encodeURIComponent('?a=10&amp;b=20'); 同时开发，数据请求 api 目录 git 冲突目录方案在 api 目录下新建一个目录，目录对应一级 tab,这个目录内放置一个 index.js ，最后把二级 tab 组件所使用的 api 请求都在这个 index.js 内引入。123456789101112131415161718// 目前|- api |- pageA.ts |- pageB.ts// 建议|- api |- pageA |- index.js |- aaa.js |- bbb.js |- pageB |- index.js |- aaa.js |- bbb.js |- ccc.js 组件嵌套过深组件一般不要超过三层,最多四层,层级过深可能会导致数据传递过深，在做一些颗粒度比较细的操作的时候，处理起来较为繁琐，可以使用 redux 等状态管理工具替代。 代码过滤掉你没考虑到的情况例如一个函数，你只想操作字符串，那你必须在函数开头就只允许参数是字符串 12345function parse (str:string)&#123; if (typeof(str) === 'string' ) &#123; &#125;&#125; 业务代码里面的异步请求需要 try catchajax 请求，使用 try catch，错误提示后端返回,并且做一些失败后的状态操作例如进入列表页，我们需要一个 loading 状态，然后去请求数据,可是失败之后，也需要把 loading 状态去掉,把 loading 隐藏的代码就写在 finally 里面。 12345678910111213141516171819202122getStudentList = async () =&gt; &#123; try &#123; this.setState(&#123; loading: true, isEmpty: false &#125;); await getStudentList(&#123;&#125;); this.setState(&#123; loading: false, isEmpty: true &#125;); &#125; catch (e) &#123; // TODO console.log(e) &#125; finally &#123; // 失败之后的一些兜底操作 this.setState(&#123; loading: false, isEmpty: true &#125;); &#125;&#125;; setState有三种用法12345678910111213141516171819202122// 对象this.setState(&#123;&#125;)// 函数，一般是用于在setState之前做一些操作this.setState( () =&gt; &#123; // TODO console.log('') return &#123; a:300 &#125; &#125;)// 第二个参数，一般是用于在setState之后做一些操作this.setState(&#123; a:300&#125;, () =&gt; &#123; // TODO&#125;) setState可能是同步的 setState 在react里的合成事件和钩子函数中是“异步”的。 setState 在原生事件和 setTimeout 中是同步的。 不要在 setState 前面加 awaitsetState 前面也是可以带 await 的，会变成同步设置状态,但这是一种巧合，不确定未来哪个版本就不支持了，为了遵循 react 框架的设计原则，我们使用回掉函数的形式。 12345678910111213141516171819// badfunc = async (name, value, status) =&gt; &#123; await this.setState(&#123; name &#125;); // TODO&#125;;// goodfunc = (name, value, status) =&gt; &#123; this.setState( &#123; name &#125;, () =&gt; &#123; // TODO &#125; );&#125;; 阻止事件默认行为在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。 在 componentWillUnmount 里面去除副作用的函数 清除 EventListener 中止数据请求 清除定时器 key对于组件中的 key 优化，起到最大化重用 dom 1234567//badthis.state.dataAry.map((item, index) =&gt; &#123; return &lt;span key=&#123;index&#125; /&gt;;&#125;);//goodthis.state.dataAry.map(item =&gt; &lt;span key=&#123;item.id&#125; /&gt;); for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）1234567891011121314151617//badconst arr = [];const key = '';for (key in obj) &#123; arr.push(obj[key]);&#125;//goodconst arr = [];const key = '';for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; arr.push(obj[key]); &#125;&#125; 第三方库函数的使用用 try catch 包裹，防止第三方库的出现错误，导致整个程序崩溃 12345678910111213141516171819202122232425262728293031323334/* * Echart 用于代绘制图表，但当其自身发生错误时，可能影响到业务代码的执行 */// badconst iniDom = document.getElementById('init-container');const echartObj = echarts.init(iniDom);this.setState( &#123; echartObj &#125;, () =&gt; &#123; const &#123; echartObj &#125; = this.state; // 更新图表 echartObj.setOption(CHART_CONFIG, true); &#125;);// goodtry &#123; const iniDom = document.getElementById('init-container'); const echartObj = echarts.init(iniDom); this.setState( &#123; echartObj &#125;, () =&gt; &#123; const &#123; echartObj &#125; = this.state; // 更新图表 echartObj.setOption(CHART_CONFIG, true); &#125; );&#125; catch (error) &#123; // TODO&#125; 防止 xss 攻击input，textarea 等标签，不要直接把 html 文本直接渲染在页面上,使用 xssb 等过滤之后再输出到标签上; 12345678import &#123; html2text &#125; from 'xss';render()&#123; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: html2text(htmlContent) &#125;&#125;/&gt;&#125; 在组件中获取真实 dom使用 16 版本后的 createRef()函数 1234567891011121314class MyComponent extends React.Component&lt;iProps, iState&gt; &#123; constructor(props) &#123; super(props); this.inputRef = React.createRef(); &#125; render() &#123; return &lt;input type="text" ref=&#123;this.inputRef&#125; /&gt;; &#125; componentDidMount() &#123; this.inputRef.current.focus(); &#125;&#125; 减少魔法数字写代码的时候尽量减少一些未知含义的数字，尽量用英文单词。例如type === 0的时候做了一些操作，让人不知所以然。 12345678910111213141516171819202122232425// badif (type !== 0) &#123; // TODO&#125;// goodconst STATUS: Record&lt;string, any&gt; = &#123; READY: 0, FETCHING: 1, FAILED: 2&#125;;if (type === STATUS.READY) &#123; // TODO&#125;// bestenum STATUS &#123; // 就绪 READY = 0, // 请求中 FETCHING = 1, // 请求失败 FAILED = 2,&#125; 如果需要优化 react 性能（一般用不到）如果组件的 state 和 props 都是简单类型，可以继承 PureComponent 而不是 Component 1234567891011121314import &#123; Component, PureComponent &#125; from 'react';// badclass Message extends Component &#123; render() &#123; return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;; &#125;&#125;// goodclass Message extends PureComponent &#123; render() &#123; return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;; &#125;&#125; Event 事件对象类型很多小伙伴用了很久的ts,都不知道常用 Event 事件对象类型：ClipboardEvent 剪贴板事件对象DragEvent 拖拽事件对象ChangeEvent Change 事件对象KeyboardEvent 键盘事件对象MouseEvent 鼠标事件对象TouchEvent 触摸事件对象WheelEvent 滚轮事件对象AnimationEvent 动画事件对象TransitionEvent 过渡事件对象 12345import &#123; MouseEvent &#125; from 'react';interface IProps &#123; onClick(event: MouseEvent&lt;HTMLDivElement&gt;): void;&#125; 使用私有属性取代state状态对于一些不需要控制ui的状态属性，我们可以直接绑到this上， 即私有属性，没有必要弄到this.state上，不然会触发渲染机制，造成性能浪费 例如请求翻页数据的时候,我们都会有个变量。 1234567891011// badstate: IState = &#123; pageNo:1, pageSize:10&#125;;// good queryParams:Record&lt;string,any&gt; = &#123; pageNo:1, pageSize:10&#125; 代码细粒度的思考总结四句话。我们在写组件或者函数的的时候，工具函数和业务逻辑抽离，表单校验和业务抽离、事件函数和业务抽离，ajax和业务抽离。例如有些页面是通过location.href跳转的，我们有些业务逻辑等都是放到didmountMount,但是后期改需求，可能要用react-router进行跳转，可能要改的逻辑就会很多了，所以函数抽离出来，需求更新就少改一点代码。如果还不确定如何划分函数的细粒度，我有个建议。使用过两次以上的代码，要抽离组件或者函数，两次的可以不用 if else 等判断太多了，后期难以维护。个人觉得if else 嵌套深看起来也不会太难受，难受的是，项目迭代久之后，自己都忘记曾经写过这些代码，而且类型多或者不确定有什么类型，是否后期还会加的情况下，改起来就非常复杂了，而且很容易踩坑和背锅。用配置取代if嵌套，大概就是抽离一个config.ts出来，里面放一些配置。 1234567891011121314151617181920212223242526272829303132333435363738例如你的业务代码里面，会根据不同url参数，代码会执行不同的逻辑./info?type=wechat&amp;uid=123456&amp;const qsObj = qs(window.location.url)const urlType = qsObj.type// bad if (urlType === 'wechat') &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125;// good config.tconst urlTypeConfig: Record&lt;string, typeItem&gt; = [ 'wechat': &#123; // key 就是对应的type name: 'wechat', show: ['header', 'footer', 'wechat'] // 展示什么，可能是异步的 pession: ['admin'], // 权限是什么，可能是异步的 &#125;, 'zhifubao': &#123; // key 就是对应的type name: 'zhifubao', show: ['header', 'footer', 'zhifubao'] // 展示什么，可能是异步的 pession: ['admin'], // 权限是什么，可能是异步的 &#125;,]// 业务逻辑const qsObj = qs(window.location.url)const urlType = qsObj.typeurlTypeConfig.forEach(item =&gt; &#123; if(urlType === item.type) &#123; doSomeThing(item.show) &#125;&#125;) 不要使用renderXXX,要使用函数式组件发现团队一些小伙伴为了减少render函数里面的代码量，会把一些元素拆分到函数里面。 12345678910111213141516171819// bad renderHeader = () =&gt; &#123; return (&lt;div /&gt;) &#125; renderBody = () =&gt; &#123; return (&lt;div /&gt;) &#125; renderFooter = () =&gt; &#123; return (&lt;div /&gt;) &#125; render()&#123; return( &lt;div&gt; renderHeader() renderBody() renderFooter() &lt;/div&gt; ) &#125; 更好的办法，是用函数式组件取代在当前组件里面写方法123456789101112131415161718192021// good function RenderHeader(props) = &#123; return (&lt;div /&gt;) &#125; function RenderBody(props) = &#123; return (&lt;div /&gt;) &#125; function RenderFooter(props) = &#123; return (&lt;div /&gt;) &#125;class Component extends React.Component&lt;iProps, iState&gt;&#123; render () &#123; return( &lt;div&gt; &lt;RenderHeader /&gt; &lt;RenderBody /&gt; &lt;RenderFooter /&gt; &lt;/div&gt; ) &#125;&#125; a标签安全问题使用a标签打开一个新窗口过程中的安全问题。新页面中可以使用window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过window.opener.location，访问到原始页面的location对象在带有target=”_blank”的a标签中，加上rel=”noopener”属性。如果使用window.open的方式打开页面，将opener对象置为空。 12var newWindow = window.open();newWindow.opener = null; void 0 替代undefined123456clearSessioin = () =&gt; &#123; req.session.userName = undefined; req.session.userName = void 0&#125; 前端不要操作cookie在做一些前后端鉴权的时候，后端应该开启domain,secure,httponly严格模式，禁止前端操作cookie，防止csrf攻击。 转载自：https://juejin.im/post/5ce24f8ae51d45106477bd45]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Hexo NexT.Pisces]]></title>
      <url>%2F2019%2F05%2F06%2Fhexo-next-des%2F</url>
      <content type="text"><![CDATA[Next 主题官网 Hexo 博客官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 的常用语法]]></title>
      <url>%2F2019%2F05%2F06%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[简介Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown 支持嵌入 html 标签。注意：Markdown 使用 #、+、* 等符号来标记， 符号后面必须跟上至少1个空格才有效！ Markdown的常用语法标题Markdown 标题支持两种形式： 用 # 标记在 标题开头 加上1~6个#，依次代表一级标题、二级标题….六级标题 代码如下：123456# 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题 列表Markdown 支持有序列表和无序列表。无序列表使用 - 、 + 和 * 作为列表标记：1234567891011- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示： 1231. Red2. Green3. Blue 效果如下： Red Green Blue 引用引用以 &gt; 来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。常见的引用写法： 1&gt; 这是一段引用 // 在 `&gt;` 后面有 1 个空格 效果如下： 这是一段引用，在 &gt; 后面有 1 个空格 Next 主题内置引用标签，使用方式 1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 效果如下：这是一段来自 Next 主题内置引用标签， default 样式主题的引用 这是一段来自 Next 主题内置引用标签， primary 样式主题的引用 这是一段来自 Next 主题内置引用标签， success 样式主题的引用 这是一段来自 Next 主题内置引用标签， info 样式主题的引用 这是一段来自 Next 主题内置引用标签， warning 样式主题的引用 这是一段来自 Next 主题内置引用标签， danger 样式主题的引用 强调两个*或-代表加粗，一个*或-代表斜体，~~代表删除。 12345**加粗文本** 或者 __加粗文本__*斜体文本* 或者_斜体文本_~~删除文本~~ 效果如下：加粗文本 或者 加粗文本斜体文本 或者斜体文本删除文本 图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式： 123图片：![]() ![图片文本(可忽略)](图片地址)链接：[]() [链接文本](链接地址) 链接又分为行内式、参考式和自动链接： 12345678910111213这是行内式链接：[ConnorLin&apos;s Blog](http://connorlin.github.io)。这是参考式链接：[ConnorLin&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。[url]: http://connorlin.github.io/ &quot;ConnorLin&apos;s Blog&quot;链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://connorlin.github.io&gt;这是图片：![][avatar][avatar]: https://connorlin.github.io/images/avatar.jpg 效果如下：这是行内式链接：ConnorLin’s Blog。 这是参考式链接：ConnorLin’s Blog，其中url为链接标记，可置于文中任意位置。 这是自动链接：直接使用&lt;&gt;括起来 http://connorlin.github.io 这是图片： 代码代码分为 行内代码 和 代码块。 行内代码用两个反单引号(前后各一个)表示，例如：code。代码块用三个反单引号，例如： 1console.log('....') 表格表格对齐格式 居左：:—- 居中：:—-:或—– 居右：—-: 例子： 123456|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333| 效果如下： 标题 标题 标题 居左测试文本 居中测试文本 居右测试文本 居左测试文本1 居中测试文本2 居右测试文本3 居左测试文本11 居中测试文本22 居右测试文本33 居左测试文本111 居中测试文本222 居右测试文本333 分隔线在一行中用三个以上的 *、 -、_ 来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。效果均为一条分割线：1234567*****_____-----* * * * * 效果如下： 相关内容转载自：https://www.jianshu.com/p/82e730892d42 参考资料1：http://www.cnblogs.com/skyhuangdan/p/5485069.html 参考资料2：https://www.appinn.com/markdown/ 主要是为了方便自己书写用，最起码有个留存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 相同的正则多次调用 test() 返回的值却不同的问题]]></title>
      <url>%2F2019%2F04%2F25%2Fjavascript-regexp-test-g%2F</url>
      <content type="text"><![CDATA[代码如下：123var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.test(15328044636)); // =&gt; trueconsole.log(reg.test(15328044636)); // =&gt; false 问题原因这是因为正则 reg 的 g 属性，设置的全局匹配。RegExp 有一个 lastIndex 属性，来保存索引开始位置。上面的问题，第一次调用的 lastIndex 值为0，到了第二次调用，值变成了11。如果正则匹配失败，lastIndex 会被重置为 0。 123var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 trueconsole.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 11 false 解决方案第一种方案是将 g 去掉，关闭全局匹配。第二种就是在每次匹配之前将 lastIndex 的值设置为0。 1234var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 truereg.lastIndex = 0;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 true 本文转载自：https://www.jianshu.com/p/a9840a5bc6cc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 正则表达式]]></title>
      <url>%2F2019%2F04%2F25%2Fjavascript-regexp%2F</url>
      <content type="text"><![CDATA[在 JavaScript 中，正则表达式(Regular Expressions)也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 创建一个正则表达式你可以使用以下两种方法之一构建一个正则表达式：使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示： 123var regex = /ab+c/;var regex = /ab+c/gi; 或者调用 RegExp 对象的构造函数，如下所示： 123let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi"); 正则表达式字符匹配攻略 正则表达式是匹配模式，要么匹配字符，要么匹配位置。 两种模糊匹配如果正则只有精确匹配是没多大意义的，比如 /hello/ ，也只能匹配字符串中的 &quot;hello&quot; 这个子串。 123var regex = /hello/;console.log( regex.test("hello") ); // =&gt; trueconsole.log( regex.test("hel333lo") ); // =&gt; false 正则表达式之所以强大，是因为其能实现模糊匹配。而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。 横向模糊匹配 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。其实现的方式是使用量词。譬如 {m,n} ，表示连续出现最少 m 次，最多 n 次。比如 /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 “a” ，接下来是2到5个字符 “b” ，最后是字符 “c” 。 测试如下：1234var regex = /ab&#123;2,5&#125;c/g;var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";console.log( string.match(regex) ); // =&gt; ["abbc", "abbbc", "abbbbc", "abbbbbc"] Tips: 案例中用的正则是 /ab{2,5}c/g ，后面多了 g ，它是正则的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g 是单词 global 的首字母。 纵向模糊匹配 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如 [abc] ，表示该字符可以是字符 “a”、“b”、“c” 中的任何一个。比如 /a[123]b/ 可以匹配如下三种字符串：”a1b”、”a2b”、”a3b”。 测试如下：1234var regex = /a[123]b/g;var string = "a0b a1b a2b a3b a4b";console.log( string.match(regex) ); // =&gt; ["a1b", "a2b", "a3b"] 要掌握横向和纵向模糊匹配，基本能解决很大部分正则匹配问题。 字符组需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如 [abc] ，表示匹配一个字符，它可以是 “a”、“b”、“c” 之一。 范围表示法如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。例如 [123456abcdefGHIJKLM] ，可以写成 [1-6a-fG-M] 。用连字符 - 来省略和简写。因为连字符有特殊用途，如果要匹配 “a”、“-”、“z” 这三者中任意一个字符，该怎么做呢？不能写成 [a-z] ，因为其表示小写字符中的任何一个字符。可以写成如下的方式：[-az] 或 [az-] 或 [a\-z] 。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 测试如下：123var regex = new RegExp(/[1-6a-fG-M]/);console.log( regex.test('123456abcdefGHIJKLM') ); // =&gt; true 排除字符组纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 “a”、”b”、”c” 。此时就是排除字符组（反义字符组）的概念。例如 [^abc] ，表示是一个除 “a”、”b”、”c” 之外的任意一个字符。字符组的第一位放 ^（脱字符），表示求反的概念。 测试如下：123var regex = new RegExp(/[^abc]/);console.log( regex.test('abc') ); // =&gt; falseconsole.log( regex.test('222') ); // =&gt; true 常见的简写形式有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。 \d 就是 [0-9] 。表示是一位数字。记忆方式：其英文是digit（数字）。\D 就是 [^0-9] 。表示除数字外的任意字符。\w 就是 [0-9a-zA-Z_] 。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\W 是 [^0-9a-zA-Z_] 。非单词字符。\s 是 [ \t\v\n\r\f] 。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式： s 是 space character 的首字母。\S 是 [^ \t\v\n\r\f] 。 非空白符。.就是 [^\n\r\u2028\u2029] 。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。 量词量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式。 简写形式 {m,} 表示至少出现 m 次。{m} 等价于 {m,m} ，表示出现 m 次。? 等价于 {0,1} ，表示出现或者不出现。记忆方式：问号的意思表示，有吗？+ 等价于 {1,} ，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。* 等价于 {0,} ，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 测试如下：12345678910111213141516171819202122232425262728// &#123;m,&#125; 表示至少出现m次。var regex1 = new RegExp(/ac&#123;2,&#125;r/);regex1.test('accr'); // =&gt; trueregex1.test('acr'); // =&gt; false// &#123;m&#125; 等价于 &#123;m,m&#125;，表示出现 m 次var regex2 = new RegExp(/ac&#123;3&#125;r/);regex2.test('acccr'); // =&gt; trueregex2.test('accr'); // =&gt; false// ? 等价于&#123;0,1&#125;，表示出现或者不出现。记忆方式：问号的意思表示，有吗？var regex3 = new RegExp(/abc?r/);console.log(regex3.test('abcr')); // =&gt; trueconsole.log(regex3.test('abbr')); // =&gt; falseconsole.log(regex3.test('abr')); // =&gt; true// + 等价于&#123;1,&#125;，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。var regex4 = new RegExp(/ac+r/);console.log(regex4.test('acr')); // =&gt; trueconsole.log(regex4.test('accr')); // =&gt; trueconsole.log(regex4.test('abr')); // =&gt; false// * 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。var regex5 = new RegExp(/abc*r/);console.log(regex5.test('abcr')); // =&gt; trueconsole.log(regex5.test('abccr')); // =&gt; trueconsole.log(regex5.test('abr')); // =&gt; trueconsole.log(regex5.test('ar')); // =&gt; false 贪婪匹配和惰性匹配例子如下：1234var regex = /\d&#123;2,5&#125;/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["123", "1234", "12345", "12345"] 其中正则 /\d{2,5}/ ，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要6个。你能给我3个，我就要3个。反正只要在能力范围内，越多越好。而惰性匹配，就是尽可能少的匹配： 1234var regex = /\d&#123;2,5&#125;?/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["12", "12", "34", "12", "34", "12", "34", "56"] 其中 /\d{2,5}?/ 表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下： {m,n}? {m,}? ?? +? *? 对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？ 多选分支一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。具体形式如下：(p1|p2|p3) ，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。例如要匹配 “good” 和 “nice” 可以使用 /good|nice/ 。测试如下： 123var regex = /good|nice/g;var string = "good idea, nice try.";console.log( string.match(regex) ); // =&gt; ["good", "nice"] 但有个事实我们应该注意，比如我用 /good|goodbye/ ，去匹配 “goodbye” 字符串时，结果是 “good” 123var regex = /good|goodbye/g;var string = "goodbye";console.log( string.match(regex) ); // =&gt; ["good"] 而把正则改成 /goodbye|good/ ，结果是： 123var regex = /goodbye|good/g;var string = "goodbye";console.log( string.match(regex) ); // =&gt; ["goodbye"] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 案例分析匹配字符，无非就是字符组、量词和分支结构的组合使用。下面找几个例子演练一下（其中，每个正则并不是只有唯一写法，可以有多种，就不一一列举了）： 匹配16进制颜色值 要求匹配：#ffbbad、#Fc01DF、#FFF、#ffE 分析：表示一个16进制字符，可以用字符组 [0-9a-fA-F] 。其中字符可以出现3或6次，需要是用量词和分支结构。使用分支结构时，需要注意顺序。 1234var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;var string = "#ffbbad #Fc01DF #FFF #ffE";console.log( string.match(regex) ); // =&gt; ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"] 匹配时间 要求匹配：23:59、02:07 分析：共4位数字，第一位数字可以为 [0-2] 。当第1位为2时，第2位可以为 [0-3] ，其他情况时，第2位为 [0-9] 。第3位数字为 [0-5] ，第4位为 [0-9] 123var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;console.log( regex.test("23:59") ); // =&gt; trueconsole.log( regex.test("02:07") ); // =&gt; true 如果也要求匹配7:9，也就是说时分前面的0可以省略。此时正则变成： 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test("23:59") ); console.log( regex.test("02:07") ); console.log( regex.test("7:9") ); // =&gt; true// =&gt; true// =&gt; true 匹配日期 比如 yyyy-mm-dd 格式为例。要求匹配：2017-06-10 分析：年，四位数字即可，可用 [0-9]{4} 。月，共12个月，分两种情况01、02、……、09和10、11、12，可用 (0[1-9]|1[0-2]) 。日，最大31天，可用 (0[1-9]|[12][0-9]|3[01]) 。正则如下： 123var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;console.log( regex.test("2017-06-10") ); // =&gt; true Tips： /^[0-9] 这个 ^ 表示：匹配以数字开始的字符串(从左向右匹配)。$/ 这个 $ 表示：匹配以数字结尾的字符串(从后向前匹配)。如果 ^ 在 [] 中出现，那么就是非的意思了，不再是从开头匹配的意思。 正则表达式位置匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。 什么是位置呢？位置是相邻字符之间的位置。比如，下图中箭头所指的地方： 如何匹配位置呢？在ES5中，共有6个锚字符： ^ $ \b \B (?=p) (?!p) ^和$^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。 比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）： 12var result = "hello".replace(/^|$/g, '#');console.log(result); // =&gt; "#hello#" 多行匹配模式时，二者是行的概念，这个需要我们的注意： 1234567var result = "I\nlove\njavascript".replace(/^|$/gm, '#');console.log(result);/*#I##love##javascript#*/ Tips：JavaScript 正则标志 /g , /i , /m 说明 1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加 /g 最多只会匹配一个 2、/i 表示匹配的时候不区分大小写 3、/m 表示多行匹配，什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$ 符号。 \b 和 \B\b 是单词边界，具体就是 \w 和 \W 之间的位置，也包括 \w 和 ^ 之间的位置，也包括 \w 和 $ 之间的位置。比如一个文件名是”[JS] Lesson_01.mp4”中的 \b，如下： 12var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');console.log(result); // =&gt; "[#JS#] #Lesson_01#.#mp4#" 为什么匹配结果是这样呢？分析如下：首先，我们知道，\w 是字符组 [0-9a-zA-Z_] 的简写形式(单词字符)，即 \w 是字母数字或者下划线的中任何一个字符。而 \W 是排除字符组 [^0-9a-zA-Z_] 的简写形式(非单词字符)，即 \W 是 \w 以外的任何一个字符。此时我们可以看看”[#JS#] #Lesson_01#.#mp4#”中的每一个”#”，是怎么来的。 第一个”#”，两边是”[“与”J”，是 \W 和 \w 之间的位置。 第二个”#”，两边是”S”与”]”，也就是 \w 和 \W 之间的位置。 第三个”#”，两边是空格与”L”，也就是 \W 和 \w 之间的位置。 第四个”#”，两边是”1”与”.”，也就是 \w 和 \W 之间的位置。 第五个”#”，两边是”.”与”m”，也就是 \W 和 \w 之间的位置。 第六个”#”，其对应的位置是结尾，但其前面的字符”4”是 \w ，即 \w 和 $ 之间的位置。 知道了 \b 的概念后，那么 \B 也就相对好理解了。\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b ，剩下的都是 \B 的。具体说来就是 \w 与 \w 、 \W 与 \W 、^ 与 \W ，\W 与 $ 之间的位置。比如上面的例子，把所有 \B 替换成 “#”： 12var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');console.log(result); // =&gt; "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4" (?=p) 和 (?!p)(?=p)，其中p是一个子模式，即p前面的位置。比如(?=l)，表示’l’字符前面的位置，例如： 12var result = "hello".replace(/(?=l)/g, '#');console.log(result); // =&gt; "he#l#lo" 而(?!p)就是(?=p)的反面意思，比如： 12var result = "hello".replace(/(?!l)/g, '#');console.log(result); // =&gt; "#h#ell#o#" 二者的学名分别是 positive lookahead 和 negative lookahead。中文翻译分别是正向先行断言和负向先行断言。ES6中，还支持 positive lookbehind 和 negative lookbehind。具体是(?&lt;=p)和(?&lt;!p)。比如(?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符。而在个人看来(?=p)就与^一样好理解，就是p前面的那个位置。 x(?=y) 仅匹配被y跟随的x。 例如，/Jack(?=Sprat)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 时，才会匹配它。/Jack(?=Sprat|Frost)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分。 x(?!y) 仅匹配不被y跟随的x。举个例子，/\d+(?!\.)/ 只会匹配不被点（.）跟随的数字。/\d+(?!\.)/.exec(&#39;3.141&#39;) 匹配”141”，而不是”3.141”相关断言（Assertions）学习资料可以看看这里：MDN、博客、百科 位置的特性对于位置的理解，我们可以理解成空字符 “”。比如”hello”字符串等价于如下的形式： 1"hello" === "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + ""; // =&gt; true 也等价于： 1"hello" == "" + "" + "hello" // =&gt; true 因此，把 /^hello$/ 写成 /^^hello$$$/ ，是没有任何问题的： 12var result = /^^hello$$$/.test("hello");console.log(result); // =&gt; true 甚至可以写成更复杂的: 12var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");console.log(result); // =&gt; true 也就是说字符之间的位置，可以写成多个。把位置理解空字符，是对位置非常有效的理解方式。 相关案例不匹配任何东西的正则让你写个正则不匹配任何东西/.^/因为此正则要求只有一个字符，但该字符后面是开头。 数字的千位分隔符表示法比如把”12345678”，变成”12,345,678”。可见是需要把相应的位置替换成”,”。思路是什么呢？ 弄出最后一个逗号使用 (?=\d{3}$) 就可以做到： 123// 在字符最后3个数字前面加一个逗号var result = "12345678".replace(/(?=\d&#123;3&#125;$)/g, ',')console.log(result); // =&gt; "12345,678" 弄出所有的逗号因为逗号出现的位置，要求后面3个数字一组，也就是 \d{3} 至少出现一次。此时可以使用量词+： 12var result = "12345678".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result); // =&gt; "12,345,678" 匹配其余案例写完正则后，多验证几个案例，此时我们会发现问题： 12var result = "123456789".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result); // =&gt; ",123,456,789" 因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。怎么解决呢？我们要求匹配到这个位置不能是开头。我们知道匹配开头可以使用 ^ ，但要求这个位置不是开头怎么办？(?!^) 测试如下： 12345678var string1 = "12345678", string2 = "123456789";var reg = /(?!^)(?=(\d&#123;3&#125;)+$)/g;var result = string1.replace(reg, ',')console.log(result); // =&gt; "12,345,678"result = string2.replace(reg, ',');console.log(result); // =&gt; "123,456,789" 123456.3435 如果要匹配这种数据格式呢？就是保留小数并且千分位逗号分割 12345// 小数点前面的数字，每隔三个数加一个 ','var string = '123456.3435';var reg = /(\d)(?=(\d&#123;3&#125;)+\.)/g;var result = string.replace(reg, '$1,')console.log(result); // =&gt; "123,456.3435" Tips: var a = 222122122.6754;var b = a.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, &#39;$1,&#39;); 这行代码，可以实现四舍五入保留2位小数点，并且千分位逗号分割，这是项目中很常见的一个需求 test, exec, match, replace 用法介绍注：pattern 为 RegExp 的实例, str 为 String 的实例 用法 说明 返回值 pattern.test(str) 判断 str 是否包含匹配结果 包含返回 true ，不包含返回 false pattern.exec(str) 根据 pattern 对 str 进行正则匹配 返回匹配结果数组，如匹配不到返回 null str.match(pattern) 根据 pattern 对 str 进行正则匹配 返回匹配结果数组，如匹配不到返回 null str.replace(pattern, replacement) 根据 pattern 进行正则匹配,把匹配结果替换为 replacement 返回一个新的字符串 str.search(pattern) 根据 pattern 对 str 进行正则匹配 返回匹配到的位置索引，如匹配不到返回 -1 str.split(pattern) pattern 可以是一个字符串或正则表达式，使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法 返回源字符串以分隔符出现位置分隔而成的一个 Array Tips：当字符串为空时，split() 返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 如果空字符串 (&#39;&#39;) 被用作分隔符，则字符串会在每个字符之间分割。 正则用法更多详情]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[灵活运用 JavaScript 开发技巧]]></title>
      <url>%2F2019%2F03%2F01%2Fjavascript-skill%2F</url>
      <content type="text"><![CDATA[Array Skill 统计元素个数 123456const arr = [0, 1, 1, 2, 2, 2];const count = arr.reduce((t, c) =&gt; &#123; t[c] = t[c] ? ++ t[c] : 1; return t;&#125;, &#123;&#125;);// count =&gt; &#123; 0: 1, 1: 2, 2: 3 &#125; 快速创建数据列表 12const data = new Array(5).fill(&#123;id: 1&#125;);// data =&gt; [&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;] Tips: fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 创建指定长度数组 12const arr = [...new Array(5).keys()];// arr =&gt; [0, 1, 2, 3, 4] 创建指定长度且值相等的数组 12const arr = [...new Array(3).keys()].fill(0);// arr =&gt; [0, 0, 0] Object Skill 删除无用属性 123const obj = &#123; a: 0, b: 1, c: 2 &#125;; // 只想拿b和cconst &#123; a, ...rest &#125; = obj;// rest =&gt; &#123; b: 1, c: 2 &#125; DOM Skill 显示全部 DOM 边框：调试页面元素边界时使用 123[].forEach.call($$("*"), dom =&gt; &#123; dom.style.outline = "1px solid #" + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16);&#125;); Number Skill 取最小最大值 1234const arr = [0, 1, 2];const min = Math.min(...arr);const max = Math.max(...arr);// min max =&gt; 0 2 String Skill 生成随机HEX色值 123const randomColor = () =&gt; "#" + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0");const color = randomColor();// color =&gt; "#f03665" 获取查询字符串参数 123456789// Assuming "?post=1234&amp;action=edit"var urlParams = new URLSearchParams(window.location.search);console.log(urlParams.has('post')); // trueconsole.log(urlParams.get('action')); // "edit"console.log(urlParams.getAll('action')); // ["edit"]console.log(urlParams.toString()); // "?post=1234&amp;action=edit"console.log(urlParams.append('active', '1')); // "?post=1234&amp;action=edit&amp;active=1"]]></content>
    </entry>

    
  
  
</search>
