<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[每日一题（2019-10-29）]]></title>
      <url>%2Fblog-daily%2F2019%2F12%2F12%2FDaily-Interview-Question-2%2F</url>
      <content type="text"><![CDATA[第 0002 题：Vue 中的 computed 和 watch 的区别在哪里computed：计算属性 计算属性是由 data 中的已知值，得到的一个新值。 这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。 计算属性不在 data 中，计算属性新值的相关已知值在 data 中。 具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数。 别人变化影响我自己。 watch：监听数据的变化 监听data中数据的变化。 监听的数据就是data中的已知值。 无缓存性，页面重新渲染时值不变化也会执行。 我的变化影响别人。 公司：虾皮 watch 擅长处理的场景：一个数据影响多个数据 computed 擅长处理的场景：一个数据受多个数据影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义 Echarts 图表悬浮框的位置]]></title>
      <url>%2Fblog-daily%2F2019%2F08%2F12%2Fecharts-tooltip%2F</url>
      <content type="text"><![CDATA[由于项目需求，悬浮框内容较多，会出现悬浮框(tooltip)很长或者很宽的现象，而太长了，就会被 Echarts 溢出隐藏了，所以需要自定义定位需求 需求描述：鼠标悬浮在左侧某一个点时，悬浮框悬停在点的右侧；鼠标悬停在右侧某一个点时，悬浮框悬停在点的左侧。 首先明确一点，我们需要借助 tooltip.position 属性。理想的思路是我们在回调函数中获取鼠标每次悬停的坐标，然后再判断这个坐标是否处于此容器(也就是这个Echarts图表)的左侧或者右侧；判断命中后我们再改变 tooltip 的位置，并返回给函数。 效果图：【左侧悬浮】 效果图：【右侧悬浮】 效果图：【溢出显示】 1234567891011121314151617// 关健代码tooltip: &#123; position: function (position) &#123; let dom = document.getElementById('chartDom'); if (dom) &#123; // 获取容器的宽度 let chartsWidth = dom.offsetWidth; // 判断悬停点落在容器的哪测 if (position[0] &lt; (chartsWidth / 2)) &#123; position[0] = position[0]; &#125; else &#123; position[0] = position[0] - 130; &#125; &#125; return [position[0], position[1]]; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React 生命周期]]></title>
      <url>%2Fblog-daily%2F2019%2F08%2F02%2Freact-component%2F</url>
      <content type="text"><![CDATA[防止自己忘掉 React 的一些生命周期方法，方便自己回忆和查阅。 componentDidUpdate() componentDidUpdate(prevProps, prevState, snapshot) componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。 当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。 123456componentDidUpdate(prevProps) &#123; // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125;&#125; 你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 技巧]]></title>
      <url>%2Fblog-daily%2F2019%2F07%2F26%2FCSS-skill%2F</url>
      <content type="text"><![CDATA[padding 配合 background-clip 属性，可以制作一些特殊形状：123456789101112131415161718192021222324/*三道杠*/.icon1 &#123; box-sizing: border-box; display: inline-block; width: 12px; height: 10px; padding: 2px 0; border-top: 2px solid currentColor; border-bottom: 2px solid currentColor; background: currentColor; /*注意如果此处背景颜色属性用缩写的话，需要放到其他背景属性的前面，否则会覆盖前面的属性值（此处为background-clip）为默认值*/ background-clip: content-box;&#125;/*双层圆点*/.icon2 &#123; display: inline-block; width: 12px; height: 12px; padding: 2px; border: 2px solid currentColor; border-radius: 50%; background-color: currentColor; background-clip: content-box;&#125; .icon1 { box-sizing: border-box; display: inline-block; width: 12px; height: 10px; padding: 2px 0; margin-right: 20px; border-top: 2px solid currentColor; border-bottom: 2px solid currentColor; background: currentColor; background-clip: content-box; } /*双层圆点*/ .icon2 { display: inline-block; width: 12px; height: 12px; padding: 2px; border: 2px solid currentColor; border-radius: 50%; background-color: currentColor; background-clip: content-box; } 实时预览如下：（currentColor 是 css 中为数不多的变量，指当前文字的颜色值，非常好用）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 名词解释]]></title>
      <url>%2Fblog-daily%2F2019%2F07%2F18%2Fjavascript-glossary%2F</url>
      <content type="text"><![CDATA[变量提升（hoisting）var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日一题（2019-07-18）]]></title>
      <url>%2Fblog-daily%2F2019%2F07%2F18%2FDaily-Interview-Question-1%2F</url>
      <content type="text"><![CDATA[第 0001 题：请写出如下代码的打印结果123456789var name = 'Tom';(function() &#123; if (typeof name == 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 公司：京东 【答案】：Goodbye Jack 【解析】：var 关键字有变量提升，它定义的变量会提升到函数的顶部。题目中立即执行函数的中的变量 name 的定义被提升到了顶部，并在初始化赋值之前是 undefined，所以 typeof name == &#39;undefined。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可能是你需要的 react + typescript 50条规范和经验]]></title>
      <url>%2Fblog-daily%2F2019%2F07%2F11%2Freact-typescript%2F</url>
      <content type="text"><![CDATA[注释文件顶部的注释，包括描述、作者、日期12345/** * @description xxxxxx * @author chengfeng * @since 19/05/21 */ 模块的注释123456/** * 拷贝数据 * @param &#123;*&#125; data 要拷贝的源数据 * @param &#123;boolean&#125; [isDeep=false] 是否深拷贝，默认浅拷贝 * @return &#123;*&#125; 返回拷贝后的数据 */ 业务代码注释1/*业务代码注释*/ 变量注释12345678interface IState &#123; // 名字 name: string; // 电话 phone: number; // 地址 address: string;&#125; 引用组件顺序 先引用外部组件库,,再引用当前组件块级组件, 然后是 common 里的公共函数库最后是 css 样式 12345import * as React from 'react';import &#123; Dropdown, Menu, Icon &#125; from 'antd';import Header from './Header';import toast from 'common/toast';import './index.less'; 引号 使用单引号,或者 es6 的反引号 缩进 使用两个空格 1234const handleCheck = () =&gt; &#123; onCancel &amp;&amp; onCancel(); onClose &amp;&amp; onClose();&#125;; 分号 每行末尾都要加分号。 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。1234567// not goodif (condition) doSomething();// goodif (condition) &#123; doSomething();&#125; 空格 二元和三元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 123456789// bad++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2; 用作代码块起始的左花括号 { 前必须有一个空格。 12345678910111213141516171819// badif (condition)&#123;&#125;while (condition)&#123;&#125;function funcName()&#123;&#125;// goodif (condition) &#123;&#125;while (condition) &#123;&#125;function funcName() &#123;&#125; if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 12345678910111213141516171819// badif(condition) &#123;&#125;while(condition) &#123;&#125;(function() &#123;&#125;)();// goodif (condition) &#123;&#125;while (condition) &#123;&#125;(function () &#123;&#125;)(); 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 12345678910111213// badvar obj = &#123; a : 1, b:2, c :3&#125;;// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;; 换行 每个独立语句结束后必须换行。 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行 1234567891011121314151617181920212223242526272829303132333435// badvar obj = &#123; a: 1 , b: 2 , c: 3,&#125;;function test()&#123; ...&#125;for (const key in object) &#123; if (object.hasOwnProperty(key)) &#123; const element = object[key]; &#125;&#125;// goodvar obj = &#123; a: 1, b: 2, c: 3,&#125;;function test() &#123; ...&#125;for (const key in object) &#123; if (object.hasOwnProperty(key)) &#123; const element = object[key]; &#125;&#125; 下列关键字后：else, catch, finally 不需要换行 123456789101112131415161718192021222324252627282930313233// badif (condition) &#123; ...&#125;else &#123; ...&#125;try &#123; ...&#125;catch (e) &#123; ...&#125;finally &#123; ...&#125;// goodif (condition) &#123; ...&#125; else &#123; ...&#125;try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 数组、对象 对象属性名不需要加引号； 对象以缩进的形式书写，不要写在一行； 数组最后不要有逗号。 对象最后要有逗号。 1234567891011121314151617181920// badconst a = &#123; 'b': 1&#125;;const a = &#123;b: 1&#125;;const a = &#123; b: 1, c: 2&#125;;const arr = [1, 2, 3, 4,];// goodconst a = &#123; b: 1, c: 2,&#125;;const arr = [1, 2, 3, 4]; 命名 类名: 大驼峰式风格，字母和数字，例如：AbcTest。禁止汉字、特殊符号，禁止非大驼峰式风格。 函数名: 小驼峰式风格，字母和数字，例如：abcTest。禁止汉字、特殊符号，禁止非小驼峰式风格，例如snake_case等。 变量名: 同函数名。 常量: 全大写风格，大写字母、数字和下划线，单词之间以下划线分隔，例如：ABC_TEST。禁止汉字、特殊符号、小写字母。 使用 onXxx 形式作为 props 中用于回调的属性名称。 1234interface IProps &#123; onClose?: () =&gt; void; onOk?: (item: Record&lt;string, any&gt;) =&gt; void;&#125; 组件内的事件函数使用 handle 开头尾,handleCheckBtn。 使用 withXxx 形式的词作为高阶组件的名称。 接口命名前面带上 I 表示 interface 12interface IProps &#123;&#125;interface IState &#123;&#125; 类型断言12345678910111213141516171819202122232425// badfunction getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'.// bad function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125;// goodfunction getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125; interface声明顺序日常用到比较多的是四种，只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后12345678interface iProps &#123; readonly x: number; readonly y: number; name: string; age: number; height?: number; [propName: string]: any;&#125; ts好用的相关工具泛型 Record&lt;string,any&gt; 用这个来声明对象结构的类型 12345// 用于定义一个javascript的对象，key是字符串，value是任意类型const people:Record&lt;string,any&gt; = &#123; name: 'chengfeng', age: 10&#125; Partial 作用是将传入的属性变为可选项. 123456789interface iPeople &#123; title: string; name: string;&#125;const people: Partial&lt;Todo&gt; = &#123; title: 'Delete inactive users',&#125;;定义的结构可以是接口iPeople的任意key Readonly 作用是将传入的属性变为变成只读 12345678910interface iPeople &#123; title: string; name: string;&#125;const people: Readonly&lt;Todo&gt; = &#123; title: 'todo list', name: 'chenfeng';&#125;;title name属性就是只读的了 Required 的作用是将传入的属性变为必选项 123456interface iPeople &#123; title?: string; name?: string;&#125;const people1: Props = &#123; title: 'ts' &#125;; // OKconst people22: Required&lt;iPeople&gt; = &#123; title: 'ts' &#125;; // Error: property 'name' missing ts一些好用的小tips keyof 123456interface iPeople &#123; name: string; age: number&#125;type T = keyof iPeople // -&gt; "name" | "age" in 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; 规范其他 不要使用 var 声明变量 不会被修改的变量使用 const 声明 去除声明但未被引用的代码 禁止在代码里使用 debug 不允许有空的代码块 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state，123456789// badconstructor ()&#123; this.setState(&#123; people: this.props.people &#125;)&#125;// goodstate: IState = &#123; people: &#123;&#125;,&#125;; 渲染默认值 添加非空判断可以提高代码的稳健性,例如后端返回的一些值,可能会出现不存在的情况，应该要给默认值. 123456789// badrender()&#123; &#123;name&#125;&#125;// goodrender()&#123; &#123;name || ''&#125;&#125; 还有一种情况，就是本来后端应该返回一个数组给你，但是数据库取不到数据，可能后端给你返回了null,然后前端null.length。这样就gg了 123456789101112131415161718192021// badconst &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);list 可能是null或者undefinedlist.length将直接导致前端报错this.setState(&#123; status: STATUS.READY, apps: list, total: totalCount, page: page,&#125;);// good const &#123; list, totalCount &#125; = await getPeopleList(keyword, page, pageSize);this.setState(&#123; status: STATUS.READY, apps: list || [], total: totalCount || 0, page: page,&#125;); 不确定的属性，最后却疯狂的用…访问不存在的属性例如一些地方，不确定这个变量里面到底有什么，但自己觉得有，就疯狂的…,最明显的就是后端返回了一个对象给你，前端拿到之后判断都不判断直接 data.dataList.forEach()123456789// badconst data = await getPeopleList(keyword, page, pageSize);data.dataList.forEach() // 直接挂了// goodconst data = await getPeopleList(keyword, page, pageSize);if (data &amp;&amp; data.dataList &amp;&amp; Array.isArray(data.dataList) &#123; data.dataList.forEach() &#125; 数据格式转换把字符串转整型可以使用 + 号12let maxPrice = +form.maxPrice.value;let maxPrice = Number(form.maxPrice.value); 转成 boolean 值用 !!1let mobile = !!ua.match(/iPhone|iPad|Android|iPod|Windows Phone/); 判断条件真假js 中以下为假,其他情况为真 false null undefined 0 ‘’ (空字符串) NaN 简单组件可以使用函数代替1234567891011// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; 对于常用的属性进行缓存12345678// badthis.props.app.openid;this.state.time// goodconst &#123; app &#125; = this.props;const &#123; time &#125; = this.state;console.log(app.openid) input 输入框使用 trim()12345678// badthis.props.app.openid;this.state.time// goodconst &#123; app &#125; = this.props;const &#123; time &#125; = this.state;console.log(app.openid) 使用 location 跳转前需要先转义12345// badwindow.location.href = redirectUrl + '?a=10&amp;b=20';// goodwindow.location.href = redirectUrl + encodeURIComponent('?a=10&amp;b=20'); 同时开发，数据请求 api 目录 git 冲突目录方案在 api 目录下新建一个目录，目录对应一级 tab,这个目录内放置一个 index.js ，最后把二级 tab 组件所使用的 api 请求都在这个 index.js 内引入。123456789101112131415161718// 目前|- api |- pageA.ts |- pageB.ts// 建议|- api |- pageA |- index.js |- aaa.js |- bbb.js |- pageB |- index.js |- aaa.js |- bbb.js |- ccc.js 组件嵌套过深组件一般不要超过三层,最多四层,层级过深可能会导致数据传递过深，在做一些颗粒度比较细的操作的时候，处理起来较为繁琐，可以使用 redux 等状态管理工具替代。 代码过滤掉你没考虑到的情况例如一个函数，你只想操作字符串，那你必须在函数开头就只允许参数是字符串 12345function parse (str:string)&#123; if (typeof(str) === 'string' ) &#123; &#125;&#125; 业务代码里面的异步请求需要 try catchajax 请求，使用 try catch，错误提示后端返回,并且做一些失败后的状态操作例如进入列表页，我们需要一个 loading 状态，然后去请求数据,可是失败之后，也需要把 loading 状态去掉,把 loading 隐藏的代码就写在 finally 里面。 12345678910111213141516171819202122getStudentList = async () =&gt; &#123; try &#123; this.setState(&#123; loading: true, isEmpty: false &#125;); await getStudentList(&#123;&#125;); this.setState(&#123; loading: false, isEmpty: true &#125;); &#125; catch (e) &#123; // TODO console.log(e) &#125; finally &#123; // 失败之后的一些兜底操作 this.setState(&#123; loading: false, isEmpty: true &#125;); &#125;&#125;; setState有三种用法12345678910111213141516171819202122// 对象this.setState(&#123;&#125;)// 函数，一般是用于在setState之前做一些操作this.setState( () =&gt; &#123; // TODO console.log('') return &#123; a:300 &#125; &#125;)// 第二个参数，一般是用于在setState之后做一些操作this.setState(&#123; a:300&#125;, () =&gt; &#123; // TODO&#125;) setState可能是同步的 setState 在react里的合成事件和钩子函数中是“异步”的。 setState 在原生事件和 setTimeout 中是同步的。 不要在 setState 前面加 awaitsetState 前面也是可以带 await 的，会变成同步设置状态,但这是一种巧合，不确定未来哪个版本就不支持了，为了遵循 react 框架的设计原则，我们使用回掉函数的形式。 12345678910111213141516171819// badfunc = async (name, value, status) =&gt; &#123; await this.setState(&#123; name &#125;); // TODO&#125;;// goodfunc = (name, value, status) =&gt; &#123; this.setState( &#123; name &#125;, () =&gt; &#123; // TODO &#125; );&#125;; 阻止事件默认行为在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。 在 componentWillUnmount 里面去除副作用的函数 清除 EventListener 中止数据请求 清除定时器 key对于组件中的 key 优化，起到最大化重用 dom 1234567//badthis.state.dataAry.map((item, index) =&gt; &#123; return &lt;span key=&#123;index&#125; /&gt;;&#125;);//goodthis.state.dataAry.map(item =&gt; &lt;span key=&#123;item.id&#125; /&gt;); for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）1234567891011121314151617//badconst arr = [];const key = '';for (key in obj) &#123; arr.push(obj[key]);&#125;//goodconst arr = [];const key = '';for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; arr.push(obj[key]); &#125;&#125; 第三方库函数的使用用 try catch 包裹，防止第三方库的出现错误，导致整个程序崩溃 12345678910111213141516171819202122232425262728293031323334/* * Echart 用于代绘制图表，但当其自身发生错误时，可能影响到业务代码的执行 */// badconst iniDom = document.getElementById('init-container');const echartObj = echarts.init(iniDom);this.setState( &#123; echartObj &#125;, () =&gt; &#123; const &#123; echartObj &#125; = this.state; // 更新图表 echartObj.setOption(CHART_CONFIG, true); &#125;);// goodtry &#123; const iniDom = document.getElementById('init-container'); const echartObj = echarts.init(iniDom); this.setState( &#123; echartObj &#125;, () =&gt; &#123; const &#123; echartObj &#125; = this.state; // 更新图表 echartObj.setOption(CHART_CONFIG, true); &#125; );&#125; catch (error) &#123; // TODO&#125; 防止 xss 攻击input，textarea 等标签，不要直接把 html 文本直接渲染在页面上,使用 xssb 等过滤之后再输出到标签上; 12345678import &#123; html2text &#125; from 'xss';render()&#123; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: html2text(htmlContent) &#125;&#125;/&gt;&#125; 在组件中获取真实 dom使用 16 版本后的 createRef()函数 1234567891011121314class MyComponent extends React.Component&lt;iProps, iState&gt; &#123; constructor(props) &#123; super(props); this.inputRef = React.createRef(); &#125; render() &#123; return &lt;input type="text" ref=&#123;this.inputRef&#125; /&gt;; &#125; componentDidMount() &#123; this.inputRef.current.focus(); &#125;&#125; 减少魔法数字写代码的时候尽量减少一些未知含义的数字，尽量用英文单词。例如type === 0的时候做了一些操作，让人不知所以然。 12345678910111213141516171819202122232425// badif (type !== 0) &#123; // TODO&#125;// goodconst STATUS: Record&lt;string, any&gt; = &#123; READY: 0, FETCHING: 1, FAILED: 2&#125;;if (type === STATUS.READY) &#123; // TODO&#125;// bestenum STATUS &#123; // 就绪 READY = 0, // 请求中 FETCHING = 1, // 请求失败 FAILED = 2,&#125; 如果需要优化 react 性能（一般用不到）如果组件的 state 和 props 都是简单类型，可以继承 PureComponent 而不是 Component 1234567891011121314import &#123; Component, PureComponent &#125; from 'react';// badclass Message extends Component &#123; render() &#123; return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;; &#125;&#125;// goodclass Message extends PureComponent &#123; render() &#123; return &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;; &#125;&#125; Event 事件对象类型很多小伙伴用了很久的ts,都不知道常用 Event 事件对象类型：ClipboardEvent 剪贴板事件对象DragEvent 拖拽事件对象ChangeEvent Change 事件对象KeyboardEvent 键盘事件对象MouseEvent 鼠标事件对象TouchEvent 触摸事件对象WheelEvent 滚轮事件对象AnimationEvent 动画事件对象TransitionEvent 过渡事件对象 12345import &#123; MouseEvent &#125; from 'react';interface IProps &#123; onClick(event: MouseEvent&lt;HTMLDivElement&gt;): void;&#125; 使用私有属性取代state状态对于一些不需要控制ui的状态属性，我们可以直接绑到this上， 即私有属性，没有必要弄到this.state上，不然会触发渲染机制，造成性能浪费 例如请求翻页数据的时候,我们都会有个变量。 1234567891011// badstate: IState = &#123; pageNo:1, pageSize:10&#125;;// good queryParams:Record&lt;string,any&gt; = &#123; pageNo:1, pageSize:10&#125; 代码细粒度的思考总结四句话。我们在写组件或者函数的的时候，工具函数和业务逻辑抽离，表单校验和业务抽离、事件函数和业务抽离，ajax和业务抽离。例如有些页面是通过location.href跳转的，我们有些业务逻辑等都是放到didmountMount,但是后期改需求，可能要用react-router进行跳转，可能要改的逻辑就会很多了，所以函数抽离出来，需求更新就少改一点代码。如果还不确定如何划分函数的细粒度，我有个建议。使用过两次以上的代码，要抽离组件或者函数，两次的可以不用 if else 等判断太多了，后期难以维护。个人觉得if else 嵌套深看起来也不会太难受，难受的是，项目迭代久之后，自己都忘记曾经写过这些代码，而且类型多或者不确定有什么类型，是否后期还会加的情况下，改起来就非常复杂了，而且很容易踩坑和背锅。用配置取代if嵌套，大概就是抽离一个config.ts出来，里面放一些配置。 1234567891011121314151617181920212223242526272829303132333435363738例如你的业务代码里面，会根据不同url参数，代码会执行不同的逻辑./info?type=wechat&amp;uid=123456&amp;const qsObj = qs(window.location.url)const urlType = qsObj.type// bad if (urlType === 'wechat') &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125; else if () &#123; doSomeThing()&#125;// good config.tconst urlTypeConfig: Record&lt;string, typeItem&gt; = [ 'wechat': &#123; // key 就是对应的type name: 'wechat', show: ['header', 'footer', 'wechat'] // 展示什么，可能是异步的 pession: ['admin'], // 权限是什么，可能是异步的 &#125;, 'zhifubao': &#123; // key 就是对应的type name: 'zhifubao', show: ['header', 'footer', 'zhifubao'] // 展示什么，可能是异步的 pession: ['admin'], // 权限是什么，可能是异步的 &#125;,]// 业务逻辑const qsObj = qs(window.location.url)const urlType = qsObj.typeurlTypeConfig.forEach(item =&gt; &#123; if(urlType === item.type) &#123; doSomeThing(item.show) &#125;&#125;) 不要使用renderXXX,要使用函数式组件发现团队一些小伙伴为了减少render函数里面的代码量，会把一些元素拆分到函数里面。 12345678910111213141516171819// bad renderHeader = () =&gt; &#123; return (&lt;div /&gt;) &#125; renderBody = () =&gt; &#123; return (&lt;div /&gt;) &#125; renderFooter = () =&gt; &#123; return (&lt;div /&gt;) &#125; render()&#123; return( &lt;div&gt; renderHeader() renderBody() renderFooter() &lt;/div&gt; ) &#125; 更好的办法，是用函数式组件取代在当前组件里面写方法123456789101112131415161718192021// good function RenderHeader(props) = &#123; return (&lt;div /&gt;) &#125; function RenderBody(props) = &#123; return (&lt;div /&gt;) &#125; function RenderFooter(props) = &#123; return (&lt;div /&gt;) &#125;class Component extends React.Component&lt;iProps, iState&gt;&#123; render () &#123; return( &lt;div&gt; &lt;RenderHeader /&gt; &lt;RenderBody /&gt; &lt;RenderFooter /&gt; &lt;/div&gt; ) &#125;&#125; a标签安全问题使用a标签打开一个新窗口过程中的安全问题。新页面中可以使用window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过window.opener.location，访问到原始页面的location对象在带有target=”_blank”的a标签中，加上rel=”noopener”属性。如果使用window.open的方式打开页面，将opener对象置为空。 12var newWindow = window.open();newWindow.opener = null; void 0 替代undefined123456clearSessioin = () =&gt; &#123; req.session.userName = undefined; req.session.userName = void 0&#125; 前端不要操作cookie在做一些前后端鉴权的时候，后端应该开启domain,secure,httponly严格模式，禁止前端操作cookie，防止csrf攻击。 转载自：https://juejin.im/post/5ce24f8ae51d45106477bd45]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 的常用语法]]></title>
      <url>%2Fblog-daily%2F2019%2F05%2F06%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[简介Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown 支持嵌入 html 标签。注意：Markdown 使用 #、+、* 等符号来标记， 符号后面必须跟上至少1个空格才有效！ Markdown的常用语法标题Markdown 标题支持两种形式： 用 # 标记在 标题开头 加上1~6个#，依次代表一级标题、二级标题….六级标题 代码如下：123456# 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题 列表Markdown 支持有序列表和无序列表。无序列表使用 - 、 + 和 * 作为列表标记：1234567891011- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示： 1231. Red2. Green3. Blue 效果如下： Red Green Blue 引用引用以 &gt; 来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。常见的引用写法： 1&gt; 这是一段引用 // 在 `&gt;` 后面有 1 个空格 效果如下： 这是一段引用，在 &gt; 后面有 1 个空格 Next 主题内置引用标签，使用方式 1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 效果如下：这是一段来自 Next 主题内置引用标签， default 样式主题的引用 这是一段来自 Next 主题内置引用标签， primary 样式主题的引用 这是一段来自 Next 主题内置引用标签， success 样式主题的引用 这是一段来自 Next 主题内置引用标签， info 样式主题的引用 这是一段来自 Next 主题内置引用标签， warning 样式主题的引用 这是一段来自 Next 主题内置引用标签， danger 样式主题的引用 强调两个*或-代表加粗，一个*或-代表斜体，~~代表删除。 12345**加粗文本** 或者 __加粗文本__*斜体文本* 或者_斜体文本_~~删除文本~~ 效果如下：加粗文本 或者 加粗文本斜体文本 或者斜体文本删除文本 图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式： 123图片：![]() ![图片文本(可忽略)](图片地址)链接：[]() [链接文本](链接地址) 链接又分为行内式、参考式和自动链接： 12345678910111213这是行内式链接：[ConnorLin&apos;s Blog](http://connorlin.github.io)。这是参考式链接：[ConnorLin&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。[url]: http://connorlin.github.io/ &quot;ConnorLin&apos;s Blog&quot;链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://connorlin.github.io&gt;这是图片：![][avatar][avatar]: https://connorlin.github.io/images/avatar.jpg 效果如下：这是行内式链接：ConnorLin’s Blog。 这是参考式链接：ConnorLin’s Blog，其中url为链接标记，可置于文中任意位置。 这是自动链接：直接使用&lt;&gt;括起来 http://connorlin.github.io 这是图片： 代码代码分为 行内代码 和 代码块。 行内代码用两个反单引号(前后各一个)表示，例如：code。代码块用三个反单引号，例如： 1console.log('....') 表格表格对齐格式 居左：:—- 居中：:—-:或—– 居右：—-: 例子： 123456|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333| 效果如下： 标题 标题 标题 居左测试文本 居中测试文本 居右测试文本 居左测试文本1 居中测试文本2 居右测试文本3 居左测试文本11 居中测试文本22 居右测试文本33 居左测试文本111 居中测试文本222 居右测试文本333 分隔线在一行中用三个以上的 *、 -、_ 来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。效果均为一条分割线：1234567*****_____-----* * * * * 效果如下： 相关内容转载自：https://www.jianshu.com/p/82e730892d42 参考资料1：http://www.cnblogs.com/skyhuangdan/p/5485069.html 参考资料2：https://www.appinn.com/markdown/ 主要是为了方便自己书写用，最起码有个留存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Hexo NexT.Pisces]]></title>
      <url>%2Fblog-daily%2F2019%2F05%2F06%2Fhexo-next-des%2F</url>
      <content type="text"><![CDATA[Next 主题官网 Hexo 博客官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 正则表达式]]></title>
      <url>%2Fblog-daily%2F2019%2F04%2F25%2Fjavascript-regexp%2F</url>
      <content type="text"><![CDATA[在 JavaScript 中，正则表达式(Regular Expressions)也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 创建一个正则表达式你可以使用以下两种方法之一构建一个正则表达式：使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示： 123var regex = /ab+c/;var regex = /ab+c/gi; 或者调用 RegExp 对象的构造函数，如下所示： 123let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi"); 正则表达式字符匹配攻略 正则表达式是匹配模式，要么匹配字符，要么匹配位置。 两种模糊匹配如果正则只有精确匹配是没多大意义的，比如 /hello/ ，也只能匹配字符串中的 &quot;hello&quot; 这个子串。 123var regex = /hello/;console.log( regex.test("hello") ); // =&gt; trueconsole.log( regex.test("hel333lo") ); // =&gt; false 正则表达式之所以强大，是因为其能实现模糊匹配。而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。 横向模糊匹配 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。其实现的方式是使用量词。譬如 {m,n} ，表示连续出现最少 m 次，最多 n 次。比如 /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 “a” ，接下来是2到5个字符 “b” ，最后是字符 “c” 。 测试如下：1234var regex = /ab&#123;2,5&#125;c/g;var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";console.log( string.match(regex) ); // =&gt; ["abbc", "abbbc", "abbbbc", "abbbbbc"] Tips: 案例中用的正则是 /ab{2,5}c/g ，后面多了 g ，它是正则的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g 是单词 global 的首字母。 纵向模糊匹配 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如 [abc] ，表示该字符可以是字符 “a”、“b”、“c” 中的任何一个。比如 /a[123]b/ 可以匹配如下三种字符串：”a1b”、”a2b”、”a3b”。 测试如下：1234var regex = /a[123]b/g;var string = "a0b a1b a2b a3b a4b";console.log( string.match(regex) ); // =&gt; ["a1b", "a2b", "a3b"] 要掌握横向和纵向模糊匹配，基本能解决很大部分正则匹配问题。 字符组需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如 [abc] ，表示匹配一个字符，它可以是 “a”、“b”、“c” 之一。 范围表示法如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。例如 [123456abcdefGHIJKLM] ，可以写成 [1-6a-fG-M] 。用连字符 - 来省略和简写。因为连字符有特殊用途，如果要匹配 “a”、“-”、“z” 这三者中任意一个字符，该怎么做呢？不能写成 [a-z] ，因为其表示小写字符中的任何一个字符。可以写成如下的方式：[-az] 或 [az-] 或 [a\-z] 。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 测试如下：123var regex = new RegExp(/[1-6a-fG-M]/);console.log( regex.test('123456abcdefGHIJKLM') ); // =&gt; true 排除字符组纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 “a”、”b”、”c” 。此时就是排除字符组（反义字符组）的概念。例如 [^abc] ，表示是一个除 “a”、”b”、”c” 之外的任意一个字符。字符组的第一位放 ^（脱字符），表示求反的概念。 测试如下：123var regex = new RegExp(/[^abc]/);console.log( regex.test('abc') ); // =&gt; falseconsole.log( regex.test('222') ); // =&gt; true 常见的简写形式有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。 \d 就是 [0-9] 。表示是一位数字。记忆方式：其英文是digit（数字）。\D 就是 [^0-9] 。表示除数字外的任意字符。\w 就是 [0-9a-zA-Z_] 。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。\W 是 [^0-9a-zA-Z_] 。非单词字符。\s 是 [ \t\v\n\r\f] 。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式： s 是 space character 的首字母。\S 是 [^ \t\v\n\r\f] 。 非空白符。.就是 [^\n\r\u2028\u2029] 。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号…中的每个点，都可以理解成占位符，表示任何类似的东西。 量词量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式。 简写形式 {m,} 表示至少出现 m 次。{m} 等价于 {m,m} ，表示出现 m 次。? 等价于 {0,1} ，表示出现或者不出现。记忆方式：问号的意思表示，有吗？+ 等价于 {1,} ，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。* 等价于 {0,} ，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 测试如下：12345678910111213141516171819202122232425262728// &#123;m,&#125; 表示至少出现m次。var regex1 = new RegExp(/ac&#123;2,&#125;r/);regex1.test('accr'); // =&gt; trueregex1.test('acr'); // =&gt; false// &#123;m&#125; 等价于 &#123;m,m&#125;，表示出现 m 次var regex2 = new RegExp(/ac&#123;3&#125;r/);regex2.test('acccr'); // =&gt; trueregex2.test('accr'); // =&gt; false// ? 等价于&#123;0,1&#125;，表示出现或者不出现。记忆方式：问号的意思表示，有吗？var regex3 = new RegExp(/abc?r/);console.log(regex3.test('abcr')); // =&gt; trueconsole.log(regex3.test('abbr')); // =&gt; falseconsole.log(regex3.test('abr')); // =&gt; true// + 等价于&#123;1,&#125;，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。var regex4 = new RegExp(/ac+r/);console.log(regex4.test('acr')); // =&gt; trueconsole.log(regex4.test('accr')); // =&gt; trueconsole.log(regex4.test('abr')); // =&gt; false// * 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。var regex5 = new RegExp(/abc*r/);console.log(regex5.test('abcr')); // =&gt; trueconsole.log(regex5.test('abccr')); // =&gt; trueconsole.log(regex5.test('abr')); // =&gt; trueconsole.log(regex5.test('ar')); // =&gt; false 贪婪匹配和惰性匹配例子如下：1234var regex = /\d&#123;2,5&#125;/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["123", "1234", "12345", "12345"] 其中正则 /\d{2,5}/ ，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要6个。你能给我3个，我就要3个。反正只要在能力范围内，越多越好。而惰性匹配，就是尽可能少的匹配： 1234var regex = /\d&#123;2,5&#125;?/g;var string = "123 1234 12345 123456";console.log( string.match(regex) ); // =&gt; ["12", "12", "34", "12", "34", "12", "34", "56"] 其中 /\d{2,5}?/ 表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下： {m,n}? {m,}? ?? +? *? 对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？ 多选分支一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。具体形式如下：(p1|p2|p3) ，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。例如要匹配 “good” 和 “nice” 可以使用 /good|nice/ 。测试如下： 123var regex = /good|nice/g;var string = "good idea, nice try.";console.log( string.match(regex) ); // =&gt; ["good", "nice"] 但有个事实我们应该注意，比如我用 /good|goodbye/ ，去匹配 “goodbye” 字符串时，结果是 “good” 123var regex = /good|goodbye/g;var string = "goodbye";console.log( string.match(regex) ); // =&gt; ["good"] 而把正则改成 /goodbye|good/ ，结果是： 123var regex = /goodbye|good/g;var string = "goodbye";console.log( string.match(regex) ); // =&gt; ["goodbye"] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 案例分析匹配字符，无非就是字符组、量词和分支结构的组合使用。下面找几个例子演练一下（其中，每个正则并不是只有唯一写法，可以有多种，就不一一列举了）： 匹配16进制颜色值 要求匹配：#ffbbad、#Fc01DF、#FFF、#ffE 分析：表示一个16进制字符，可以用字符组 [0-9a-fA-F] 。其中字符可以出现3或6次，需要是用量词和分支结构。使用分支结构时，需要注意顺序。 1234var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;var string = "#ffbbad #Fc01DF #FFF #ffE";console.log( string.match(regex) ); // =&gt; ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"] 匹配时间 要求匹配：23:59、02:07 分析：共4位数字，第一位数字可以为 [0-2] 。当第1位为2时，第2位可以为 [0-3] ，其他情况时，第2位为 [0-9] 。第3位数字为 [0-5] ，第4位为 [0-9] 123var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;console.log( regex.test("23:59") ); // =&gt; trueconsole.log( regex.test("02:07") ); // =&gt; true 如果也要求匹配7:9，也就是说时分前面的0可以省略。此时正则变成： 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test("23:59") ); console.log( regex.test("02:07") ); console.log( regex.test("7:9") ); // =&gt; true// =&gt; true// =&gt; true 匹配日期 比如 yyyy-mm-dd 格式为例。要求匹配：2017-06-10 分析：年，四位数字即可，可用 [0-9]{4} 。月，共12个月，分两种情况01、02、……、09和10、11、12，可用 (0[1-9]|1[0-2]) 。日，最大31天，可用 (0[1-9]|[12][0-9]|3[01]) 。正则如下： 123var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;console.log( regex.test("2017-06-10") ); // =&gt; true Tips： /^[0-9] 这个 ^ 表示：匹配以数字开始的字符串(从左向右匹配)。$/ 这个 $ 表示：匹配以数字结尾的字符串(从后向前匹配)。如果 ^ 在 [] 中出现，那么就是非的意思了，不再是从开头匹配的意思。 正则表达式位置匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。 什么是位置呢？位置是相邻字符之间的位置。比如，下图中箭头所指的地方： 如何匹配位置呢？在ES5中，共有6个锚字符： ^ $ \b \B (?=p) (?!p) ^和$^（脱字符）匹配开头，在多行匹配中匹配行开头。$（美元符号）匹配结尾，在多行匹配中匹配行结尾。 比如我们把字符串的开头和结尾用”#”替换（位置可以替换成字符的！）： 12var result = "hello".replace(/^|$/g, '#');console.log(result); // =&gt; "#hello#" 多行匹配模式时，二者是行的概念，这个需要我们的注意： 1234567var result = "I\nlove\njavascript".replace(/^|$/gm, '#');console.log(result);/*#I##love##javascript#*/ Tips：JavaScript 正则标志 /g , /i , /m 说明 1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加 /g 最多只会匹配一个 2、/i 表示匹配的时候不区分大小写 3、/m 表示多行匹配，什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$ 符号。 \b 和 \B\b 是单词边界，具体就是 \w 和 \W 之间的位置，也包括 \w 和 ^ 之间的位置，也包括 \w 和 $ 之间的位置。比如一个文件名是”[JS] Lesson_01.mp4”中的 \b，如下： 12var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');console.log(result); // =&gt; "[#JS#] #Lesson_01#.#mp4#" 为什么匹配结果是这样呢？分析如下：首先，我们知道，\w 是字符组 [0-9a-zA-Z_] 的简写形式(单词字符)，即 \w 是字母数字或者下划线的中任何一个字符。而 \W 是排除字符组 [^0-9a-zA-Z_] 的简写形式(非单词字符)，即 \W 是 \w 以外的任何一个字符。此时我们可以看看”[#JS#] #Lesson_01#.#mp4#”中的每一个”#”，是怎么来的。 第一个”#”，两边是”[“与”J”，是 \W 和 \w 之间的位置。 第二个”#”，两边是”S”与”]”，也就是 \w 和 \W 之间的位置。 第三个”#”，两边是空格与”L”，也就是 \W 和 \w 之间的位置。 第四个”#”，两边是”1”与”.”，也就是 \w 和 \W 之间的位置。 第五个”#”，两边是”.”与”m”，也就是 \W 和 \w 之间的位置。 第六个”#”，其对应的位置是结尾，但其前面的字符”4”是 \w ，即 \w 和 $ 之间的位置。 知道了 \b 的概念后，那么 \B 也就相对好理解了。\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b ，剩下的都是 \B 的。具体说来就是 \w 与 \w 、 \W 与 \W 、^ 与 \W ，\W 与 $ 之间的位置。比如上面的例子，把所有 \B 替换成 “#”： 12var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');console.log(result); // =&gt; "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4" (?=p) 和 (?!p)(?=p)，其中p是一个子模式，即p前面的位置。比如(?=l)，表示’l’字符前面的位置，例如： 12var result = "hello".replace(/(?=l)/g, '#');console.log(result); // =&gt; "he#l#lo" 而(?!p)就是(?=p)的反面意思，比如： 12var result = "hello".replace(/(?!l)/g, '#');console.log(result); // =&gt; "#h#ell#o#" 二者的学名分别是 positive lookahead 和 negative lookahead。中文翻译分别是正向先行断言和负向先行断言。ES6中，还支持 positive lookbehind 和 negative lookbehind。具体是(?&lt;=p)和(?&lt;!p)。比如(?=p)，一般都理解成：要求接下来的字符与p匹配，但不能包括p的那些字符。而在个人看来(?=p)就与^一样好理解，就是p前面的那个位置。 x(?=y) 仅匹配被y跟随的x。 例如，/Jack(?=Sprat)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 时，才会匹配它。/Jack(?=Sprat|Frost)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分。 x(?!y) 仅匹配不被y跟随的x。举个例子，/\d+(?!\.)/ 只会匹配不被点（.）跟随的数字。/\d+(?!\.)/.exec(&#39;3.141&#39;) 匹配”141”，而不是”3.141”相关断言（Assertions）学习资料可以看看这里：MDN、博客、百科 位置的特性对于位置的理解，我们可以理解成空字符 “”。比如”hello”字符串等价于如下的形式： 1"hello" === "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + ""; // =&gt; true 也等价于： 1"hello" == "" + "" + "hello" // =&gt; true 因此，把 /^hello$/ 写成 /^^hello$$$/ ，是没有任何问题的： 12var result = /^^hello$$$/.test("hello");console.log(result); // =&gt; true 甚至可以写成更复杂的: 12var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");console.log(result); // =&gt; true 也就是说字符之间的位置，可以写成多个。把位置理解空字符，是对位置非常有效的理解方式。 相关案例不匹配任何东西的正则让你写个正则不匹配任何东西/.^/因为此正则要求只有一个字符，但该字符后面是开头。 数字的千位分隔符表示法比如把”12345678”，变成”12,345,678”。可见是需要把相应的位置替换成”,”。思路是什么呢？ 弄出最后一个逗号使用 (?=\d{3}$) 就可以做到： 123// 在字符最后3个数字前面加一个逗号var result = "12345678".replace(/(?=\d&#123;3&#125;$)/g, ',')console.log(result); // =&gt; "12345,678" 弄出所有的逗号因为逗号出现的位置，要求后面3个数字一组，也就是 \d{3} 至少出现一次。此时可以使用量词+： 12var result = "12345678".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result); // =&gt; "12,345,678" 匹配其余案例写完正则后，多验证几个案例，此时我们会发现问题： 12var result = "123456789".replace(/(?=(\d&#123;3&#125;)+$)/g, ',')console.log(result); // =&gt; ",123,456,789" 因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。怎么解决呢？我们要求匹配到这个位置不能是开头。我们知道匹配开头可以使用 ^ ，但要求这个位置不是开头怎么办？(?!^) 测试如下： 12345678var string1 = "12345678", string2 = "123456789";var reg = /(?!^)(?=(\d&#123;3&#125;)+$)/g;var result = string1.replace(reg, ',')console.log(result); // =&gt; "12,345,678"result = string2.replace(reg, ',');console.log(result); // =&gt; "123,456,789" 123456.3435 如果要匹配这种数据格式呢？就是保留小数并且千分位逗号分割 12345// 小数点前面的数字，每隔三个数加一个 ','var string = '123456.3435';var reg = /(\d)(?=(\d&#123;3&#125;)+\.)/g;var result = string.replace(reg, '$1,')console.log(result); // =&gt; "123,456.3435" Tips: var a = 222122122.6754;var b = a.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, &#39;$1,&#39;); 这行代码，可以实现四舍五入保留2位小数点，并且千分位逗号分割，这是项目中很常见的一个需求 test, exec, match, replace 用法介绍注：pattern 为 RegExp 的实例, str 为 String 的实例 用法 说明 返回值 pattern.test(str) 判断 str 是否包含匹配结果 包含返回 true ，不包含返回 false pattern.exec(str) 根据 pattern 对 str 进行正则匹配 返回匹配结果数组，如匹配不到返回 null str.match(pattern) 根据 pattern 对 str 进行正则匹配 返回匹配结果数组，如匹配不到返回 null str.replace(pattern, replacement) 根据 pattern 进行正则匹配,把匹配结果替换为 replacement 返回一个新的字符串 str.search(pattern) 根据 pattern 对 str 进行正则匹配 返回匹配到的位置索引，如匹配不到返回 -1 str.split(pattern) pattern 可以是一个字符串或正则表达式，使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法 返回源字符串以分隔符出现位置分隔而成的一个 Array Tips：当字符串为空时，split() 返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 如果空字符串 (&#39;&#39;) 被用作分隔符，则字符串会在每个字符之间分割。 正则用法更多详情]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 相同的正则多次调用 test() 返回的值却不同的问题]]></title>
      <url>%2Fblog-daily%2F2019%2F04%2F25%2Fjavascript-regexp-test-g%2F</url>
      <content type="text"><![CDATA[代码如下：123var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.test(15328044636)); // =&gt; trueconsole.log(reg.test(15328044636)); // =&gt; false 问题原因这是因为正则 reg 的 g 属性，设置的全局匹配。RegExp 有一个 lastIndex 属性，来保存索引开始位置。上面的问题，第一次调用的 lastIndex 值为0，到了第二次调用，值变成了11。如果正则匹配失败，lastIndex 会被重置为 0。 123var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 trueconsole.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 11 false 解决方案第一种方案是将 g 去掉，关闭全局匹配。第二种就是在每次匹配之前将 lastIndex 的值设置为0。 1234var reg = /^1[345678][0-9]&#123;9&#125;$/g;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 truereg.lastIndex = 0;console.log(reg.lastIndex, reg.test(15328044636)); // =&gt; 0 true 本文转载自：https://www.jianshu.com/p/a9840a5bc6cc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[灵活运用 JavaScript 开发技巧]]></title>
      <url>%2Fblog-daily%2F2019%2F03%2F01%2Fjavascript-skill%2F</url>
      <content type="text"><![CDATA[Array Skill 统计元素个数 123456const arr = [0, 1, 1, 2, 2, 2];const count = arr.reduce((t, c) =&gt; &#123; t[c] = t[c] ? ++ t[c] : 1; return t;&#125;, &#123;&#125;);// count =&gt; &#123; 0: 1, 1: 2, 2: 3 &#125; 快速创建数据列表 12const data = new Array(5).fill(&#123;id: 1&#125;);// data =&gt; [&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;,&#123;id:1&#125;] Tips: fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 创建指定长度数组 12const arr = [...new Array(5).keys()];// arr =&gt; [0, 1, 2, 3, 4] 创建指定长度且值相等的数组 12const arr = [...new Array(3).keys()].fill(0);// arr =&gt; [0, 0, 0] Object Skill 删除无用属性 123const obj = &#123; a: 0, b: 1, c: 2 &#125;; // 只想拿b和cconst &#123; a, ...rest &#125; = obj;// rest =&gt; &#123; b: 1, c: 2 &#125; DOM Skill 显示全部 DOM 边框：调试页面元素边界时使用 123[].forEach.call($$("*"), dom =&gt; &#123; dom.style.outline = "1px solid #" + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16);&#125;); Number Skill 取最小最大值 1234const arr = [0, 1, 2];const min = Math.min(...arr);const max = Math.max(...arr);// min max =&gt; 0 2 String Skill 生成随机HEX色值 123const randomColor = () =&gt; "#" + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0");const color = randomColor();// color =&gt; "#f03665" 获取查询字符串参数 123456789// Assuming "?post=1234&amp;action=edit"var urlParams = new URLSearchParams(window.location.search);console.log(urlParams.has('post')); // trueconsole.log(urlParams.get('action')); // "edit"console.log(urlParams.getAll('action')); // ["edit"]console.log(urlParams.toString()); // "?post=1234&amp;action=edit"console.log(urlParams.append('active', '1')); // "?post=1234&amp;action=edit&amp;active=1"]]></content>
    </entry>

    
  
  
</search>
